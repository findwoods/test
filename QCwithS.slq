def main() {
  return BellState();
}

def BellState(){
  b:=1:ğ”¹;
  b:=H(b);
   
  c:=1:ğ”¹;
  if b{
    c := X(c);
  }

  return (b,c);

}// Bernstein-Vazirani algorithm
// - Returns s where f(x) = sÂ·x mod 2
//

def bernstein_vazirani[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!uint[n]{
  cand := 0:uint[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // âˆ‘áµ¥|vâŸ©

  if f(cand) {
    phase(Ï€);
  }

  // state ignoring normalization:
  //   âˆ‘áµ¥(-1)^f(v)  |vâŸ©
  // = âˆ‘áµ¥(-1)^(sÂ·v) |vâŸ©
  // = (|0âŸ©+(-1)^(sâ‚)|1âŸ©) âŠ— â‹¯ âŠ— (|0âŸ©+(-1)^(sâ‚™)|1âŸ©)

  for k in [0..n) { cand[k] := H(cand[k]); }

  s := measure(cand);
  return s;
}

/* TEST */

def f[n:!â„•](s:!uint[n])(x:uint[n])lifted:ğ”¹{
  y := scal(s, x)%2;
  return y==1;
}

def scal[n:!â„•](const x:uint[n], const y:uint[n])qfree:uint[n] { 
  // computes the scalar product xÂ·y
  count := 0:uint[n];
  for k in [0..n) { 
    count+=x[k] && y[k];
  }
  return count;
}

def main() {
  // test  with all secret strings on 3 bits
  for i in [0..8) {
	  s := i coerce !uint[3];
	  sâ‚€ := bernstein_vazirani(f(s));
	  assert(s==sâ‚€);
  }

  // test with secret string s = 01
  s := 1 coerce !uint[2];
  sâ‚€ := bernstein_vazirani(f(s));
  return sâ‚€;

}



// Bit-Flip code (Quantum error correction)
// - Returns the qubit Ïˆ where Ïˆ is encoded to a 3-qubit state and then  
// - passed through a noisy channel potentially flipping one of the qubits


def encode(Ïˆ:ğ”¹) mfree { // encode a single qubit Ïˆ into a 3-qubit state
    Ïˆ := (dup(Ïˆ), dup(Ïˆ), Ïˆ);
    
    return Ïˆ;
}

def correct(Ïˆ:ğ”¹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    p1 := measure(Ïˆ[0] âŠ• Ïˆ[1]);
    p2 := measure(Ïˆ[0] âŠ• Ïˆ[2]);

    // apply the appropriate correction
    if (p1 && p2) {
        Ïˆ[0] := X(Ïˆ[0]);
    } else if (p1) {
        Ïˆ[1] := X(Ïˆ[1]);
    } else if (p2) {
        Ïˆ[2] := X(Ïˆ[2]);
    }

    return Ïˆ;
}

def bit_flip_code(Ïˆ: ğ”¹, channel: ğ”¹^3 !â†’ ğ”¹^3) { // simulate the bit-flip code error-correcting process
    Ïˆ := encode(Ïˆ);
    Ïˆ := channel(Ïˆ);
    Ïˆ := correct(Ïˆ);
    Ïˆ := reverse(encode)(Ïˆ);

    return Ïˆ;
}

/* EXAMPLES */

def channel(Ïˆ:ğ”¹^3) { // flip the first qubit of a 3-qubit state
    Ïˆ[0] := X(Ïˆ[0]);
    return Ïˆ;
}

def main() {
    // Example 1: basis state
    Ïˆ := 1:ğ”¹; 
    Ï† := bit_flip_code(Ïˆ, channel); 
    // verifies that Ï† = 1
    forget(Ï† = 1);

    // Example 2: superposition
    Ïˆ := H(1:ğ”¹); 
    Ï† := bit_flip_code(Ïˆ, channel); 
    // verifies that Ï† = H(|1>)
    return Ï†;
}


def main() {
  return DecomposedCX();
}

def DecomposedCX(){
  b:=1:ğ”¹;
  b:=H(b);

  a:=1:ğ”¹;
  if a{
    b := Z(b);
  }

  b:=H(b);

  return b;
}// Deutsch-Jozsa algorithm 
// - Returns : | 0 if f is balanced (#{x, f(x)=0} = #{x, f(x)=1})
//             | 1 if f is constant (âˆ€x f(x)=0 or âˆ€x f(x)=1)


def deutsch_jozsa[n:!â„•](f: const int[n] !â†’ lifted ğ”¹):!ğ”¹{
  cand := 0:int[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // âˆ‘áµ¥|vâŸ©

  if f(cand) {
	  phase(Ï€);
  }

  // state ignoring normalization:
  // âˆ‘áµ¥(-1)^f(v)|vâŸ©

  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  //   âˆ‘áµ¥(-1)^f(v) âˆ‘áµ¤ (-1)^(uÂ·v)|uâŸ©  

  result := measure(cand);
  // probability to measure 0 is:
  // - 1 if f constant (constructive interference) 
  // - 0 if f balanced (destructive interference)
  return result==0;
}

/* TEST */

def test_balanced() {
  def balanced(x:int[2])lifted:ğ”¹{
    if (x[0]==1) { 
      return 1:ğ”¹;
    }
    else {
      return 0:ğ”¹;
    }
  } // implements a balanced function (outputs half 0 and half 1)
  x := deutsch_jozsa(balanced);
  assert(x == 0); 
  return x;
}

def test_constant() {
  def constant(x:int[2])lifted:ğ”¹{
    return 1:ğ”¹;
  } // implements a constant function (outputs only 1)
  x := deutsch_jozsa(constant);
  assert(x == 1);
  return x;
}

def main() {
  print(test_balanced()); // DJ on balanced function should output 0
  print(test_constant()); // DJ on constant function should output 1
  return;
}
def main() {
  return geometric();
}

def geometric():!â„•{
    count := 0;
    ok := true;
    while ok{
        count += 1;
        ok = measure(H(false));
    }
    return count;
}def main() {
  return GHZ();
}

def GHZ(){
  a:=0:ğ”¹;
  b:=0:ğ”¹;
  c:=0:ğ”¹;

  a:=H(a);

  if a{
    b := X(b);
  }

  if b{
    c := X(c);
  }

  return (a,b,c);

}// Grover Diffusion Operator

def groverDiffusion[n:!â„•](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(Ï€); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}
// Grover's algorithm for a known number (M) of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/ftp/arxiv/papers/0705/0705.4171.pdf


import helpers.groverDiffusion;

def grover_multiple[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹, M:!â„•):!â„•{
	nIterations:= round((Ï€/4) * sqrt(2^n/M));
	cand:=0:uint[n];
    for k in [0..n) { cand[k] := H(cand[k]); }
	
	for k in [0..nIterations){
		if f(cand){
			phase(Ï€);
		}
		cand:=groverDiffusion(cand);
	}
	return measure(cand) as !â„•;
}

/* EXAMPLE CALL */

def main(){
	f := Î»(x:uint[6])lifted:ğ”¹{ return x==4 || x==5 || x==6; }; 
	// creates an oracle which outputs one only when x is in {4,5,6}
	
	x := grover_multiple(f, 3); 
	
	assert(x==4 || x==5 || x==6); 
	// verifies that grover_multiple finds one of the right solutions

	return x;
}

/* TEST */

// This function defines tests for Grover with respectively 2, 3 and 4 solutions
def test_grover_multiple() {
	n := 6;
	def f2(x:uint[n])lifted:ğ”¹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:ğ”¹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:ğ”¹{
    	return x==7 || x==8 || x==9 || x==10;
	} // creates oracles with respectively 2, 3 and 4 solutions
	x := grover_multiple(f2, 2);
	y := grover_multiple(f3, 3);
	z := grover_multiple(f4, 4);
	// verifies that grover_multiple finds one of the right solutions
	assert(x==2 || x==3);
	assert(y==4 || y==5 || y==6);
	assert(z==7 || z==8 || z==9 || z==10);
}



// Grover's algorithm for a single solution
// - Returns the only x for which f(x) = 1
//
// - More detailed description: https://www.scottaaronson.com/qclec/22.pdf

import helpers.groverDiffusion;

def grover[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!â„•{ 
	nIterations:= round(Ï€ / 4 * sqrt(2^n));
	cand:=0:uint[n];
    for k in [0..n) {cand[k] := H(cand[k]);} 
	
	for k in [0..nIterations){
		if f(cand){
			phase(Ï€);
		}		
		// state ignoring normalization:   
    	// âˆ‘(vâ‰ w)|vâŸ© - |w*âŸ©
		cand:=groverDiffusion(cand);  
    	// âˆ‘(vâ‰ w)Î³â‚‹|vâŸ© + Î³â‚Š|w*âŸ©
	}
	return measure(cand) as !â„•;
}

/* EXAMPLE CALL */

def main() {
	f := Î»(x:uint[5])lifted:ğ”¹{return x==3;}; // creates an oracle which outputs one only when x=3
	x := grover(f); 
	assert(x==3); // verifies that grover finds the right solution

	return x;
}

/* TEST */ 

// This function defines a test for Grover
def test_grover() {
	def f(x:uint[3])lifted:ğ”¹{
    	return x==7;
	} // creates an oracle which outputs one only when x=3
	x := grover(f);
	// verifies that grover finds the right solution
	assert(x==7);

	return x;
}


// Grover's algorithm for an unknown number of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/pdf/1709.01236.pdf

import helpers.groverDiffusion;
import helpers.rand;

def grover_unknown[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!â„•{
	m := 1:!â„š;
	l := 6/5;

	while (m <= 2^(n/2)) {
		nIterations := uniformInt(floor(m) coerce !â„•) + 1;
		
		cand := 0:uint[n];
    	for k in [0..n) {cand[k] := H(cand[k]);}
		
		for k in [0..nIterations){
			if f(cand){
				phase(Ï€);
			}
		cand:=groverDiffusion(cand);
		}

		x := measure(cand);

		if f(x) {return x as !â„•;}
		else {m=l*m;}
	}

	return 0;
}

/* EXAMPLE CALL */

def main(){
	f := Î»(x:uint[5])lifted:ğ”¹{ return x==1 || x==2 || x==5 || x==8; }; 
	// creates an oracle which outputs one only when x is in {1,2,5,8}
	
	x := grover_unknown(f); 
	
	assert(x==1 || x==2 || x==5 || x==8); 
	// verifies that grover_unknown finds one of the right solutions

	return x;
}



/* TEST */ 

// This function defines tests for Grover with respectively 1, 2, 3 and 4 solutions
def test_grover_unknown() {
	n := 5;
	def f1(x:uint[n])lifted:ğ”¹{
    	return x==1;
	}
	def f2(x:uint[n])lifted:ğ”¹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:ğ”¹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:ğ”¹{
    	return x==7 || x==8 || x==9 || x==10;
	}
	 // creates oracles with respectively 1, 2, 3 and 4 solutions
	x := grover_unknown(f1);
	y := grover_unknown(f2);
	z := grover_unknown(f3);
	w := grover_unknown(f4);
	// verifies that grover_unknown finds one of the right solutions
	assert(x==1);
	assert(y==2 || y==3);
	assert(z==4 || z==5 || z==6);
	assert(w==7 || w==8 || w==9 || w==10);
}



def main() {
  return HalfAdder();
}

def HalfAdder(){
  // Define 4 Qubits - a & b inputs, s & c are sum and carry - outputs
  a:=1:ğ”¹;
  b:=1:ğ”¹;
  s:=0:ğ”¹;
  c:=0:ğ”¹;

  // XOR Gate Operation

  // CX operation on b and s qubit
  if b{
    s := X(s);
  }
  
  // CX operation on a and s
  if a{
    s := X(s);
  }

  // AND Gate Operation

  if a && b{
    c := X(c);
  }

  return (s,c);
}def CSWAP(x:ğ”¹, y:ğ”¹, z:ğ”¹) {
  if x{
    a:=z;
    z:=y;
    y:=a;
  }
  return (x,y,z);
}

def SWAP(x:ğ”¹, y:ğ”¹) {
  a:=y;
  y:=x;
  x:=a;
  return (x,y);
}

def CCX(const x:ğ”¹,const y:ğ”¹,z:ğ”¹):ğ”¹{
  if x && y{
    z := X(z);
  }
  return (z);
}

def CZ(const x:ğ”¹,y:ğ”¹):ğ”¹{
  if x{
    y := Z(y);
  }
  return y;
}

def CX(const x:ğ”¹,y:ğ”¹):ğ”¹{
  if x{
    y := X(y);
  }
  return y;
}// Phase Estimation algorithm

import qft;

def phaseEstimation[k:!â„•](
    U:int[k] !->mfree int[k],
    u:int[k], 
    precision:!â„•) {

    ancilla := 0:int[precision];
    for i in [0..precision) { ancilla[i] := H(ancilla[i]); }

    for i in [0..precision) { 
        if ancilla[i] {
            for l in [0..2^i) {
                u := U(u);
            }
        }
    }

    ancilla := reverse(QFT[precision])(ancilla);
    result := measure(ancilla);
    measure(u);
    return result;
}
// Phase-Flip code (Quantum error correction)
// - Returns the qubit Ïˆ where Ïˆ is encoded to a 3-qubit state and then  
// - passed through a noisy channel potentially flipping the phase of one of the qubits


def encode(Ïˆ:ğ”¹) mfree { // encode a single qubit Ïˆ into a 3-qubit state
    Ïˆ := (dup(Ïˆ), dup(Ïˆ), Ïˆ);
    
    return Ïˆ;}

def correct(Ïˆ:ğ”¹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    p1 := measure(Ïˆ[0] âŠ• Ïˆ[1]);
    p2 := measure(Ïˆ[0] âŠ• Ïˆ[2]);

    // apply the appropriate correction
    if (p1 && p2) {
        Ïˆ[0] := X(Ïˆ[0]);
    } else if (p1) {
        Ïˆ[1] := X(Ïˆ[1]);
    } else if (p2) {
        Ïˆ[2] := X(Ïˆ[2]);
    }

    return Ïˆ;
}

def phase_flip_code(Ïˆ: ğ”¹, channel: ğ”¹^3 !â†’ ğ”¹^3) { // simulate the phase-flip code error-correcting process
    Ïˆ := encode(Ïˆ);

    for k in [0..3) {Ïˆ[k] := H(Ïˆ[k]);}
    Ïˆ := channel(Ïˆ);
    for k in [0..3) {Ïˆ[k] := H(Ïˆ[k]);}

    Ïˆ := correct(Ïˆ);
    Ïˆ := reverse(encode)(Ïˆ);

    return Ïˆ;
}

/* EXAMPLES */

def channel(Ïˆ:ğ”¹^3) { // flip the phase of the second qubit of a 3-qubit state
    Ïˆ[1] := Z(Ïˆ[1]);
    return Ïˆ;
}

def main() {
    // Example 1: basis state
    Ïˆ := 0:ğ”¹; 
    Ï† := phase_flip_code(Ïˆ, channel); 
    // verifies that Ï† = 0
    forget(Ï† = 0);

    // Example 2: superposition
    Ïˆ := H(0:ğ”¹); 
    Ï† := phase_flip_code(Ïˆ, channel); 
    // verifies that Ï† = H(|0>)
    return Ï†;
}


// Quantum Fourier Transform


def QFT[n:!â„•](Ïˆ: int[n])mfree: int[n]{
	for k in [0..n div 2){
		(Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]);
	}
	for k in [0..n){
		Ïˆ[k] := H(Ïˆ[k]);
		for l in [k+1..n){
			if Ïˆ[l] && Ïˆ[k]{
				phase(2*Ï€ * 2^(k-l-1));
			}
		}
	}
	return Ïˆ;
}


def main(){
	Ïˆ := 2:int[2];
	return QFT(Ïˆ);
}
// Quantum Key Distribution 
// - Simulates the generation of a secure key through an insecure channel


// Helper functions

// Returns 0 or 1 with equal probability
def rand(){
    return measure(H(false));
}

// Random number generator
def uniformInt(range:!â„•){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !â„•;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def prepareState(n:!â„•) { 
    // prepares n random bits each encoded as a qubit in a random base 
    bitsA := 0:!int[n];
    basesA := 0:!int[n];
    
    for i in [0..n){ // generates random bits and random bases
	bitsA[i] = rand();
        basesA[i] = rand();
    }

    qubitsA := bitsA:int[n];
    for i in [0..n){ // encodes each qubit to be sent in the corresponding base
        if basesA[i] {qubitsA[i] = H(qubitsA[i]);}
    }

    return(bitsA, basesA, qubitsA);
}

def measureB[n:!â„•](qubitsA:int[n]) { 
    // generates n random bases to measure the received bits
    basesB := 0:!int[n];
    
    for i in [0..n){ // generates random bases
        basesB[i] = rand();
    }

    for i in [0..n){ // decodes each received qubit according to the bases
        if basesB[i] {qubitsA[i] := H(qubitsA[i]);}
    }
    bitsB := measure(qubitsA);
    return (bitsB, basesB);
}

def compareBases[n:!â„•](basesA:!int[n], basesB:!int[n]) { 
    // returns the correctly guessed bases
    indices := 0:!int[n];
    nInfo := 0:!â„•;
    indices = ~(basesA âŠ• basesB); // keeps indices where bases coincide
    for i in [0..n){ 
        nInfo+=indices[i];
    }
    return (indices, nInfo);
}

def computePresumablySharedInfo[n:!â„•](indices:!int[n], bitsA:!int[n], 
                                bitsB:!int[n], nInfo:!â„•) {

    infoA := 0:!int[nInfo]; // contains the presumbaly shared information on A part
    infoB := 0:!int[nInfo];
    count := 0:!â„•;
    i := 0:!â„•;
    while (count < nInfo) { // computes the presumably shared information
        if indices[i] {
            infoA[count] = bitsA[i];
            infoB[count] = bitsB[i];            
            count+=1;
        }
        i+=1;
    }
    return (infoA, infoB);
}

def checkEavesdropper[n:!â„•](infoA:!int[n], 
                            infoB:!int[n],
                            nSharedBits:!â„•) {
    bitsRevealed := 0:!â„•;
    noE := true;
    count := 0:!â„•;
    i := 0:!â„•;
    notAlreadyChecked := 2^n - 1 coerce !int[n];
    while (bitsRevealed < n - nSharedBits) { 
    // checks that no eavesdropper has gained info about the shared secret  
    // by comparing some bits
        i = uniformInt(n);
        if notAlreadyChecked[i] {
            // checks that random bits coincide
            noE &= (infoA[i] == infoB[i]);
            notAlreadyChecked[i] = false;
            bitsRevealed+=1;
        }
    }
    return (notAlreadyChecked, noE);
}

def computeSharedInfo[n:!â„•](indices:!int[n], bitsA:!int[n], 
                            bitsB:!int[n], nInfo:!â„•, nSharedBits:!â„•) { 
    // computes shared information
    
    // nSharedBits is the number of remaining bits after 'burning' some of them 
    // to detect the presence of an eavesdropper
    assert (nSharedBits < nInfo);

    (infoA, infoB) := computePresumablySharedInfo(indices, bitsA, bitsB, nInfo);

    (notAlreadyChecked, noE) := checkEavesdropper(infoA, infoB, nSharedBits);

    sharedInfo := 0:!uint[nSharedBits]; 
    // contains the shared information to be used if no eavesdroper has been detected
    
    count := 0:!â„•;
    i := 0:!â„•;
    while (count < nSharedBits) { // computes the shared information
        if notAlreadyChecked[i] {
            sharedInfo[count] = infoA[i];
            count+=1;
        }
        i+=1;
    }

    return (sharedInfo, noE); 
    // returns the shared information and the detection or not of an eavesdropper
}

def qkd[n:!â„•](channel: int[n] !â†’ int[n]){
    (bitsA, basesA, qubitsA) := prepareState(n); 
    // prepares the random bases and bits and the qubits to be send to B

    qubitsA := channel(qubitsA); 
    // simulates the transfer through a potentially malicious channel 

    (bitsB, basesB) := measureB(qubitsA); 
    // generates the guesses from B

    (indices, nInfo) := compareBases(basesA, basesB); 
    // compares the bases between A and B


    nSharedBits := floor((2/3)*nInfo) coerce !â„•;
    
    (sharedInfo, noE) := computeSharedInfo(indices, bitsA, bitsB, nInfo, nSharedBits);  
    // computes the shared information obtained 
    // and the potential detection of an eavesdropper
    
    return (noE, nSharedBits); 
    // returns whether an eavesdropper was detected (0 if detection)
    // and how many bits of info are shared
}

/* TEST */

def testQKDnoE() { // tests QKD with no eavesdropper 
    n := 12;
    channel := Î»(b:int[n]). b; // channel = id
    (noE, nSharedBits) := qkd[n](channel);
    assert(noE); // no detection of eavesdropper (noE=1)
    print(noE, nSharedBits);
}

def testQKDE() { // tests QKD with an eavesdropper 
    n := 12;
    channel := Î»(b:int[n]){ for i in [0..n) {b[i] := H(b[i])}; return b; }; 
    // channel alters the qubits
    (noE, nSharedBits) := qkd[n](channel);
    print(noE, nSharedBits);
}

/* EXAMPLE CALL */

def main() {
    // tests QKD both with and without an eavesdropper
    
    // test without eavesdropper should always be of the form (1,n)
    testQKDnoE();

    // test with an eavesdropper may be of the form (0,n) if its presence is detected
    testQKDE(); 
}
// Random number generators

def uniformInt(range:!â„•){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !â„•;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}

// Shor code (Quantum error correction)
// - Returns the qubit Ïˆ where Ïˆ is encoded to a 9-qubit state and then  
// - passed through a noisy channel potentially altering the state of one of the qubits


// Helper function

def applyToEach[Ï„,Ï„'](triple:Ï„^3, f: Ï„ !â†’ Ï„') { // apply a function to each element of a triple
    (h0,h1,h2) := triple;
    fTriple := (f(h0),f(h1),f(h2));

    return fTriple;
}


def triplicate(Ïˆ:ğ”¹) mfree {  // entangle a qubit with two duplicates 
    Ïˆ := (dup(Ïˆ), dup(Ïˆ), Ïˆ);

    return Ïˆ;
}

def encode(Ïˆ:B) {  // encode a single qubit Ïˆ into a 9-qubit state
    Ïˆ := triplicate(Ïˆ);
    Ïˆ := applyToEach(Ïˆ, H);
    Ïˆ := applyToEach(Ïˆ, triplicate);

    return Ïˆ;
}

def correct(Ïˆ:ğ”¹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    a1 := measure(Ïˆ[0] âŠ• Ïˆ[1]);
    a2 := measure(Ïˆ[0] âŠ• Ïˆ[2]);

    // apply the appropriate correction
    if (a1 && a2) {
        Ïˆ[0] := X(Ïˆ[0]);
    } else if (a1) {
        Ïˆ[1] := X(Ïˆ[1]);
    } else if (a2) {
        Ïˆ[2] := X(Ïˆ[2]);
    }

    return Ïˆ;
}

def correctBitFlip(Ïˆ:(B^3)^3) {  // correct a single bit-flip error in each triplet of a triplet of triplets
    Ïˆ := applyToEach(Ïˆ, correct);

    return Ïˆ;
}

def correctPhaseFlip(Ïˆ:(B^3)^3) { // correct a single phase-flip error
    Ïˆ := applyToEach(Ïˆ, reverse(triplicate));
    Ïˆ := applyToEach(Ïˆ, H);
    Ïˆ := correct(Ïˆ);

    return Ïˆ
}

def shor_code(Ïˆ:B,  channel: (B^3)^3 !â†’ (B^3)^3){ // simulate the Shor code error-correcting process
    Ïˆ := encode(Ïˆ);

    Ïˆ := channel(Ïˆ);

    Ïˆ := correctBitFlip(Ïˆ); 
    Ïˆ := correctPhaseFlip(Ïˆ);

    Ïˆ := reverse(triplicate)(Ïˆ);

    return Ïˆ;
}

/* EXAMPLES */

def channel(Ïˆ:(ğ”¹^3)^3) { // flip both one qubit and its phase in a 3x3 structure
    Ïˆ[0][1] := Z(Ïˆ[0][1]); 
    Ïˆ[0][1] := X(Ïˆ[0][1]); 
    return Ïˆ; 
}

def main() {
    // Example 1: basis state
    Ïˆ := 1:ğ”¹; 
    Ï† := shor_code(Ïˆ, channel); 
    // verifies that Ï† = 1
    forget(Ï†=1);

    // Example 2: superposition
    Ïˆ := H(1:ğ”¹); 
    Ï† := shor_code(Ïˆ, channel); 
    // verifies that Ï† = H(|1>)
    return Ï†;
}// Simon's algorithm 

def main() {
  return Simon();
}

def Simon(){
  // Initializing Qubits for Inputs - a,b,c and Oracle - d,e,f
  a:=0:ğ”¹;
  b:=0:ğ”¹;
  c:=0:ğ”¹;
  d:=0:ğ”¹;
  e:=0:ğ”¹;
  f:=0:ğ”¹;

  // Applying Hadamard to Inputs
  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Encoding 011 secret key in the Oracle

  if b{
    d := X(d);
  }

  if b{
    e := X(e);
  }

  if c{
    d := X(d);
  }

  if b{
    f := X(f);
  }

  if c{
    e := X(e);
  }

  if c{
    f := X(f);
  }

  // Applying Hadamard to Inputs

  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Measure the d,e,f qubits for variable consumption

  md:=measure(d);
  me:=measure(e);
  mf:=measure(f);

  return (a,b,c,md,me,mf);
}def main() {
  return Hadamard();
}

def Hadamard() {
  x:=0:ğ”¹;
  return H(x);
}

def PauliZ() {
  z:=1:ğ”¹;
  return Z(z);
}

def PauliY() {
  y:=1:ğ”¹;
  return Y(y);
}

def PauliX() {
  x:=0:ğ”¹;
  return X(x);
}def main() {
  return SuperDenseCoding();
}

def SuperDenseCoding(){
  a:=0:ğ”¹;
  b:=0:ğ”¹;
  
  // Bell State Preparation
  a:=H(a);
  if a{
    b := X(b);
  }

  // Alice's Operation - 11 is sent
  a:=Z(a);
  a:=X(a);

  // Bob's Operation
  if a{
    b := X(b);
  }

  a:=H(a);

  return(a,b);
}// Superposition generation
// - Generates the (normalized) superposition |0âŸ© + ... + |N-1âŸ© on k qubits  
//  
// - Requires N < 2^k

def superposition[k:!â„•](N:!â„•, qs:ğ”¹^k)mfree:ğ”¹^k{ 
    // generates the (normalized) superposition |0âŸ© + ... + |N-1âŸ© on k qubits

    assert(N <= 2^k); 
    // ensures that the biggest state |N-1âŸ© requires less than k qubits to be written
   
    n := floor(log(N)/log(2)) coerce !â„•;
    r := N - 2^n coerce !â„•;
    // decomposition N = 2^n + r

    // rotate first qubit
    (head,)~tail := qs; 
    Î¸ := 2*asin(sqrt(r)/sqrt(N));
    // sin(Î¸/2) = sqrt(r/N), cos(Î¸/2) = sqrt((N-r)/N) = sqrt(2^n/N)
	
    head := rotY(Î¸, head); 
    // |0âŸ© â†¦ cos(Î¸/2)|0âŸ© + sin(Î¸/2)|1âŸ© = sqrt(2^n/N) |0âŸ© + sqrt(r/N)|1âŸ©

    // state : 
    // (sqrt(2^n)/sqrt(N))|0âŸ©âŠ—(|0âŸ©âŠ— â‹¯ âŠ—|0âŸ©) + (sqrt(r)/sqrt(N))|1âŸ©âŠ—(|0âŸ©âŠ— â‹¯ âŠ—|0âŸ©)

    // conditionally on first qubit either prepare 
    // the uniform distribution on n qubits or 
    // (recursively) the remainder |0âŸ© + ... + |r-1âŸ©
    if head {
        tail := superposition(r, tail); // (|0âŸ© + ... + |r-1âŸ©)/sqrt(r)
    }
    else {
        for i in [0..n) { tail[i] := H(tail[i]); } // âˆ‘áµ¥|vâŸ©/sqrt(2^n)
    }

    // tail = (xâ‚, ..., xâ‚™, xâ‚™â‚Šâ‚, ..., xâ‚–) and 
    // head (= xâ‚€) is the MSB of (xâ‚, ..., xâ‚™, xâ‚€)
    for i in [0..n div 2) { (tail[i], tail[n-1-i]) := (tail[n-1-i], tail[i]); } 
    // tail = (xâ‚™, ..., xâ‚, xâ‚™â‚Šâ‚, ..., xâ‚–)
    
    qs:=(head,)~tail;                                                           
    // qs = (xâ‚€, xâ‚™, ..., xâ‚, xâ‚™â‚Šâ‚, ..., xâ‚–)
    
    for i in [0..(n+1) div 2) { (qs[i], qs[n-i]) := (qs[n-i], qs[i]); }         
    // qs = (xâ‚, ..., xâ‚™, xâ‚€, xâ‚™â‚Šâ‚, ..., xâ‚–)

    // state :   
    // (sqrt(2^n)/sqrt(N))|0âŸ©âŠ—(âˆ‘áµ¥|vâŸ©/sqrt(2^n)) + 
    // (sqrt(r)/sqrt(N))|1âŸ©âŠ—((|0âŸ© + ... + |r-1âŸ©)/sqrt(r)
    // = (1/sqrt(N))(|0âŸ© + ... + |N-1âŸ©)

    return qs;
}

/* TEST */

def test_superposition() { 
    k := 5;
    qs := vector(k, 0:ğ”¹);
    qs := superposition(19, qs);
    measure(qs);
}

/* EXAMPLE CALL */

def main() {
    N := 19;
    // generates the normalized superposition |0âŸ© + ... + |18âŸ© on 5 qubits
    qs := superposition(N,  vector(5, 0:ğ”¹)) as uint[5];

    // measures 0 <= n < 19 
    n := measure(qs); 
    assert(n < N);
    return(n);
}def main() {
  return Teleportation();
}

def Teleportation(){

  // Initialize Qubits - 'a' qubit is to be teleported by Alice to Bob
  a:=0:ğ”¹;
  b:=0:ğ”¹;
  c:=0:ğ”¹;

  // Alice's Operations

  // Creating the Bell State
  b:=H(b);

  if b{
    c := X(c);
  }

  // Alice applies CX and H to 'a' qubit

  if a{
    b := X(b);
  }

  a:=H(a);

  // Alice measures her qubits 'a' and 'b'

  ma1:=measure(a);
  ma2:=measure(b);
  print(ma1);
  print(ma2);

  // Bob's measurement

  //c:=X(c);
  //c:=Z(c);

  return (c);
}def main() {
  return UniformSuperposition[1]();
}

def UniformSuperposition[n:!â„•]():ğ”¹^n{
  qubits := vector(n,0:ğ”¹); // vector of length n filled with zeros
  for i in [0..n){
    qubits[i] := H(qubits[i]);
  }
  return qubits;
}