def main() {
  return BellState();
}

def BellState(){
  b:=1:𝔹;
  b:=H(b);
   
  c:=1:𝔹;
  if b{
    c := X(c);
  }

  return (b,c);

}// Bernstein-Vazirani algorithm
// - Returns s where f(x) = s·x mod 2
//

def bernstein_vazirani[n:!ℕ](f: const uint[n] !→ lifted 𝔹):!uint[n]{
  cand := 0:uint[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // ∑ᵥ|v⟩

  if f(cand) {
    phase(π);
  }

  // state ignoring normalization:
  //   ∑ᵥ(-1)^f(v)  |v⟩
  // = ∑ᵥ(-1)^(s·v) |v⟩
  // = (|0⟩+(-1)^(s₁)|1⟩) ⊗ ⋯ ⊗ (|0⟩+(-1)^(sₙ)|1⟩)

  for k in [0..n) { cand[k] := H(cand[k]); }

  s := measure(cand);
  return s;
}

/* TEST */

def f[n:!ℕ](s:!uint[n])(x:uint[n])lifted:𝔹{
  y := scal(s, x)%2;
  return y==1;
}

def scal[n:!ℕ](const x:uint[n], const y:uint[n])qfree:uint[n] { 
  // computes the scalar product x·y
  count := 0:uint[n];
  for k in [0..n) { 
    count+=x[k] && y[k];
  }
  return count;
}

def main() {
  // test  with all secret strings on 3 bits
  for i in [0..8) {
	  s := i coerce !uint[3];
	  s₀ := bernstein_vazirani(f(s));
	  assert(s==s₀);
  }

  // test with secret string s = 01
  s := 1 coerce !uint[2];
  s₀ := bernstein_vazirani(f(s));
  return s₀;

}



// Bit-Flip code (Quantum error correction)
// - Returns the qubit ψ where ψ is encoded to a 3-qubit state and then  
// - passed through a noisy channel potentially flipping one of the qubits


def encode(ψ:𝔹) mfree { // encode a single qubit ψ into a 3-qubit state
    ψ := (dup(ψ), dup(ψ), ψ);
    
    return ψ;
}

def correct(ψ:𝔹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    p1 := measure(ψ[0] ⊕ ψ[1]);
    p2 := measure(ψ[0] ⊕ ψ[2]);

    // apply the appropriate correction
    if (p1 && p2) {
        ψ[0] := X(ψ[0]);
    } else if (p1) {
        ψ[1] := X(ψ[1]);
    } else if (p2) {
        ψ[2] := X(ψ[2]);
    }

    return ψ;
}

def bit_flip_code(ψ: 𝔹, channel: 𝔹^3 !→ 𝔹^3) { // simulate the bit-flip code error-correcting process
    ψ := encode(ψ);
    ψ := channel(ψ);
    ψ := correct(ψ);
    ψ := reverse(encode)(ψ);

    return ψ;
}

/* EXAMPLES */

def channel(ψ:𝔹^3) { // flip the first qubit of a 3-qubit state
    ψ[0] := X(ψ[0]);
    return ψ;
}

def main() {
    // Example 1: basis state
    ψ := 1:𝔹; 
    φ := bit_flip_code(ψ, channel); 
    // verifies that φ = 1
    forget(φ = 1);

    // Example 2: superposition
    ψ := H(1:𝔹); 
    φ := bit_flip_code(ψ, channel); 
    // verifies that φ = H(|1>)
    return φ;
}


def main() {
  return DecomposedCX();
}

def DecomposedCX(){
  b:=1:𝔹;
  b:=H(b);

  a:=1:𝔹;
  if a{
    b := Z(b);
  }

  b:=H(b);

  return b;
}// Deutsch-Jozsa algorithm 
// - Returns : | 0 if f is balanced (#{x, f(x)=0} = #{x, f(x)=1})
//             | 1 if f is constant (∀x f(x)=0 or ∀x f(x)=1)


def deutsch_jozsa[n:!ℕ](f: const int[n] !→ lifted 𝔹):!𝔹{
  cand := 0:int[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // ∑ᵥ|v⟩

  if f(cand) {
	  phase(π);
  }

  // state ignoring normalization:
  // ∑ᵥ(-1)^f(v)|v⟩

  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  //   ∑ᵥ(-1)^f(v) ∑ᵤ (-1)^(u·v)|u⟩  

  result := measure(cand);
  // probability to measure 0 is:
  // - 1 if f constant (constructive interference) 
  // - 0 if f balanced (destructive interference)
  return result==0;
}

/* TEST */

def test_balanced() {
  def balanced(x:int[2])lifted:𝔹{
    if (x[0]==1) { 
      return 1:𝔹;
    }
    else {
      return 0:𝔹;
    }
  } // implements a balanced function (outputs half 0 and half 1)
  x := deutsch_jozsa(balanced);
  assert(x == 0); 
  return x;
}

def test_constant() {
  def constant(x:int[2])lifted:𝔹{
    return 1:𝔹;
  } // implements a constant function (outputs only 1)
  x := deutsch_jozsa(constant);
  assert(x == 1);
  return x;
}

def main() {
  print(test_balanced()); // DJ on balanced function should output 0
  print(test_constant()); // DJ on constant function should output 1
  return;
}
def main() {
  return geometric();
}

def geometric():!ℕ{
    count := 0;
    ok := true;
    while ok{
        count += 1;
        ok = measure(H(false));
    }
    return count;
}def main() {
  return GHZ();
}

def GHZ(){
  a:=0:𝔹;
  b:=0:𝔹;
  c:=0:𝔹;

  a:=H(a);

  if a{
    b := X(b);
  }

  if b{
    c := X(c);
  }

  return (a,b,c);

}// Grover Diffusion Operator

def groverDiffusion[n:!ℕ](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(π); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}
// Grover's algorithm for a known number (M) of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/ftp/arxiv/papers/0705/0705.4171.pdf


import helpers.groverDiffusion;

def grover_multiple[n:!ℕ](f: const uint[n] !→ lifted 𝔹, M:!ℕ):!ℕ{
	nIterations:= round((π/4) * sqrt(2^n/M));
	cand:=0:uint[n];
    for k in [0..n) { cand[k] := H(cand[k]); }
	
	for k in [0..nIterations){
		if f(cand){
			phase(π);
		}
		cand:=groverDiffusion(cand);
	}
	return measure(cand) as !ℕ;
}

/* EXAMPLE CALL */

def main(){
	f := λ(x:uint[6])lifted:𝔹{ return x==4 || x==5 || x==6; }; 
	// creates an oracle which outputs one only when x is in {4,5,6}
	
	x := grover_multiple(f, 3); 
	
	assert(x==4 || x==5 || x==6); 
	// verifies that grover_multiple finds one of the right solutions

	return x;
}

/* TEST */

// This function defines tests for Grover with respectively 2, 3 and 4 solutions
def test_grover_multiple() {
	n := 6;
	def f2(x:uint[n])lifted:𝔹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:𝔹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:𝔹{
    	return x==7 || x==8 || x==9 || x==10;
	} // creates oracles with respectively 2, 3 and 4 solutions
	x := grover_multiple(f2, 2);
	y := grover_multiple(f3, 3);
	z := grover_multiple(f4, 4);
	// verifies that grover_multiple finds one of the right solutions
	assert(x==2 || x==3);
	assert(y==4 || y==5 || y==6);
	assert(z==7 || z==8 || z==9 || z==10);
}



// Grover's algorithm for a single solution
// - Returns the only x for which f(x) = 1
//
// - More detailed description: https://www.scottaaronson.com/qclec/22.pdf

import helpers.groverDiffusion;

def grover[n:!ℕ](f: const uint[n] !→ lifted 𝔹):!ℕ{ 
	nIterations:= round(π / 4 * sqrt(2^n));
	cand:=0:uint[n];
    for k in [0..n) {cand[k] := H(cand[k]);} 
	
	for k in [0..nIterations){
		if f(cand){
			phase(π);
		}		
		// state ignoring normalization:   
    	// ∑(v≠w)|v⟩ - |w*⟩
		cand:=groverDiffusion(cand);  
    	// ∑(v≠w)γ₋|v⟩ + γ₊|w*⟩
	}
	return measure(cand) as !ℕ;
}

/* EXAMPLE CALL */

def main() {
	f := λ(x:uint[5])lifted:𝔹{return x==3;}; // creates an oracle which outputs one only when x=3
	x := grover(f); 
	assert(x==3); // verifies that grover finds the right solution

	return x;
}

/* TEST */ 

// This function defines a test for Grover
def test_grover() {
	def f(x:uint[3])lifted:𝔹{
    	return x==7;
	} // creates an oracle which outputs one only when x=3
	x := grover(f);
	// verifies that grover finds the right solution
	assert(x==7);

	return x;
}


// Grover's algorithm for an unknown number of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/pdf/1709.01236.pdf

import helpers.groverDiffusion;
import helpers.rand;

def grover_unknown[n:!ℕ](f: const uint[n] !→ lifted 𝔹):!ℕ{
	m := 1:!ℚ;
	l := 6/5;

	while (m <= 2^(n/2)) {
		nIterations := uniformInt(floor(m) coerce !ℕ) + 1;
		
		cand := 0:uint[n];
    	for k in [0..n) {cand[k] := H(cand[k]);}
		
		for k in [0..nIterations){
			if f(cand){
				phase(π);
			}
		cand:=groverDiffusion(cand);
		}

		x := measure(cand);

		if f(x) {return x as !ℕ;}
		else {m=l*m;}
	}

	return 0;
}

/* EXAMPLE CALL */

def main(){
	f := λ(x:uint[5])lifted:𝔹{ return x==1 || x==2 || x==5 || x==8; }; 
	// creates an oracle which outputs one only when x is in {1,2,5,8}
	
	x := grover_unknown(f); 
	
	assert(x==1 || x==2 || x==5 || x==8); 
	// verifies that grover_unknown finds one of the right solutions

	return x;
}



/* TEST */ 

// This function defines tests for Grover with respectively 1, 2, 3 and 4 solutions
def test_grover_unknown() {
	n := 5;
	def f1(x:uint[n])lifted:𝔹{
    	return x==1;
	}
	def f2(x:uint[n])lifted:𝔹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:𝔹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:𝔹{
    	return x==7 || x==8 || x==9 || x==10;
	}
	 // creates oracles with respectively 1, 2, 3 and 4 solutions
	x := grover_unknown(f1);
	y := grover_unknown(f2);
	z := grover_unknown(f3);
	w := grover_unknown(f4);
	// verifies that grover_unknown finds one of the right solutions
	assert(x==1);
	assert(y==2 || y==3);
	assert(z==4 || z==5 || z==6);
	assert(w==7 || w==8 || w==9 || w==10);
}



def main() {
  return HalfAdder();
}

def HalfAdder(){
  // Define 4 Qubits - a & b inputs, s & c are sum and carry - outputs
  a:=1:𝔹;
  b:=1:𝔹;
  s:=0:𝔹;
  c:=0:𝔹;

  // XOR Gate Operation

  // CX operation on b and s qubit
  if b{
    s := X(s);
  }
  
  // CX operation on a and s
  if a{
    s := X(s);
  }

  // AND Gate Operation

  if a && b{
    c := X(c);
  }

  return (s,c);
}def CSWAP(x:𝔹, y:𝔹, z:𝔹) {
  if x{
    a:=z;
    z:=y;
    y:=a;
  }
  return (x,y,z);
}

def SWAP(x:𝔹, y:𝔹) {
  a:=y;
  y:=x;
  x:=a;
  return (x,y);
}

def CCX(const x:𝔹,const y:𝔹,z:𝔹):𝔹{
  if x && y{
    z := X(z);
  }
  return (z);
}

def CZ(const x:𝔹,y:𝔹):𝔹{
  if x{
    y := Z(y);
  }
  return y;
}

def CX(const x:𝔹,y:𝔹):𝔹{
  if x{
    y := X(y);
  }
  return y;
}// Phase Estimation algorithm

import qft;

def phaseEstimation[k:!ℕ](
    U:int[k] !->mfree int[k],
    u:int[k], 
    precision:!ℕ) {

    ancilla := 0:int[precision];
    for i in [0..precision) { ancilla[i] := H(ancilla[i]); }

    for i in [0..precision) { 
        if ancilla[i] {
            for l in [0..2^i) {
                u := U(u);
            }
        }
    }

    ancilla := reverse(QFT[precision])(ancilla);
    result := measure(ancilla);
    measure(u);
    return result;
}
// Phase-Flip code (Quantum error correction)
// - Returns the qubit ψ where ψ is encoded to a 3-qubit state and then  
// - passed through a noisy channel potentially flipping the phase of one of the qubits


def encode(ψ:𝔹) mfree { // encode a single qubit ψ into a 3-qubit state
    ψ := (dup(ψ), dup(ψ), ψ);
    
    return ψ;}

def correct(ψ:𝔹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    p1 := measure(ψ[0] ⊕ ψ[1]);
    p2 := measure(ψ[0] ⊕ ψ[2]);

    // apply the appropriate correction
    if (p1 && p2) {
        ψ[0] := X(ψ[0]);
    } else if (p1) {
        ψ[1] := X(ψ[1]);
    } else if (p2) {
        ψ[2] := X(ψ[2]);
    }

    return ψ;
}

def phase_flip_code(ψ: 𝔹, channel: 𝔹^3 !→ 𝔹^3) { // simulate the phase-flip code error-correcting process
    ψ := encode(ψ);

    for k in [0..3) {ψ[k] := H(ψ[k]);}
    ψ := channel(ψ);
    for k in [0..3) {ψ[k] := H(ψ[k]);}

    ψ := correct(ψ);
    ψ := reverse(encode)(ψ);

    return ψ;
}

/* EXAMPLES */

def channel(ψ:𝔹^3) { // flip the phase of the second qubit of a 3-qubit state
    ψ[1] := Z(ψ[1]);
    return ψ;
}

def main() {
    // Example 1: basis state
    ψ := 0:𝔹; 
    φ := phase_flip_code(ψ, channel); 
    // verifies that φ = 0
    forget(φ = 0);

    // Example 2: superposition
    ψ := H(0:𝔹); 
    φ := phase_flip_code(ψ, channel); 
    // verifies that φ = H(|0>)
    return φ;
}


// Quantum Fourier Transform


def QFT[n:!ℕ](ψ: int[n])mfree: int[n]{
	for k in [0..n div 2){
		(ψ[k],ψ[n-k-1]) := (ψ[n-k-1],ψ[k]);
	}
	for k in [0..n){
		ψ[k] := H(ψ[k]);
		for l in [k+1..n){
			if ψ[l] && ψ[k]{
				phase(2*π * 2^(k-l-1));
			}
		}
	}
	return ψ;
}


def main(){
	ψ := 2:int[2];
	return QFT(ψ);
}
// Quantum Key Distribution 
// - Simulates the generation of a secure key through an insecure channel


// Helper functions

// Returns 0 or 1 with equal probability
def rand(){
    return measure(H(false));
}

// Random number generator
def uniformInt(range:!ℕ){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !ℕ;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def prepareState(n:!ℕ) { 
    // prepares n random bits each encoded as a qubit in a random base 
    bitsA := 0:!int[n];
    basesA := 0:!int[n];
    
    for i in [0..n){ // generates random bits and random bases
	bitsA[i] = rand();
        basesA[i] = rand();
    }

    qubitsA := bitsA:int[n];
    for i in [0..n){ // encodes each qubit to be sent in the corresponding base
        if basesA[i] {qubitsA[i] = H(qubitsA[i]);}
    }

    return(bitsA, basesA, qubitsA);
}

def measureB[n:!ℕ](qubitsA:int[n]) { 
    // generates n random bases to measure the received bits
    basesB := 0:!int[n];
    
    for i in [0..n){ // generates random bases
        basesB[i] = rand();
    }

    for i in [0..n){ // decodes each received qubit according to the bases
        if basesB[i] {qubitsA[i] := H(qubitsA[i]);}
    }
    bitsB := measure(qubitsA);
    return (bitsB, basesB);
}

def compareBases[n:!ℕ](basesA:!int[n], basesB:!int[n]) { 
    // returns the correctly guessed bases
    indices := 0:!int[n];
    nInfo := 0:!ℕ;
    indices = ~(basesA ⊕ basesB); // keeps indices where bases coincide
    for i in [0..n){ 
        nInfo+=indices[i];
    }
    return (indices, nInfo);
}

def computePresumablySharedInfo[n:!ℕ](indices:!int[n], bitsA:!int[n], 
                                bitsB:!int[n], nInfo:!ℕ) {

    infoA := 0:!int[nInfo]; // contains the presumbaly shared information on A part
    infoB := 0:!int[nInfo];
    count := 0:!ℕ;
    i := 0:!ℕ;
    while (count < nInfo) { // computes the presumably shared information
        if indices[i] {
            infoA[count] = bitsA[i];
            infoB[count] = bitsB[i];            
            count+=1;
        }
        i+=1;
    }
    return (infoA, infoB);
}

def checkEavesdropper[n:!ℕ](infoA:!int[n], 
                            infoB:!int[n],
                            nSharedBits:!ℕ) {
    bitsRevealed := 0:!ℕ;
    noE := true;
    count := 0:!ℕ;
    i := 0:!ℕ;
    notAlreadyChecked := 2^n - 1 coerce !int[n];
    while (bitsRevealed < n - nSharedBits) { 
    // checks that no eavesdropper has gained info about the shared secret  
    // by comparing some bits
        i = uniformInt(n);
        if notAlreadyChecked[i] {
            // checks that random bits coincide
            noE &= (infoA[i] == infoB[i]);
            notAlreadyChecked[i] = false;
            bitsRevealed+=1;
        }
    }
    return (notAlreadyChecked, noE);
}

def computeSharedInfo[n:!ℕ](indices:!int[n], bitsA:!int[n], 
                            bitsB:!int[n], nInfo:!ℕ, nSharedBits:!ℕ) { 
    // computes shared information
    
    // nSharedBits is the number of remaining bits after 'burning' some of them 
    // to detect the presence of an eavesdropper
    assert (nSharedBits < nInfo);

    (infoA, infoB) := computePresumablySharedInfo(indices, bitsA, bitsB, nInfo);

    (notAlreadyChecked, noE) := checkEavesdropper(infoA, infoB, nSharedBits);

    sharedInfo := 0:!uint[nSharedBits]; 
    // contains the shared information to be used if no eavesdroper has been detected
    
    count := 0:!ℕ;
    i := 0:!ℕ;
    while (count < nSharedBits) { // computes the shared information
        if notAlreadyChecked[i] {
            sharedInfo[count] = infoA[i];
            count+=1;
        }
        i+=1;
    }

    return (sharedInfo, noE); 
    // returns the shared information and the detection or not of an eavesdropper
}

def qkd[n:!ℕ](channel: int[n] !→ int[n]){
    (bitsA, basesA, qubitsA) := prepareState(n); 
    // prepares the random bases and bits and the qubits to be send to B

    qubitsA := channel(qubitsA); 
    // simulates the transfer through a potentially malicious channel 

    (bitsB, basesB) := measureB(qubitsA); 
    // generates the guesses from B

    (indices, nInfo) := compareBases(basesA, basesB); 
    // compares the bases between A and B


    nSharedBits := floor((2/3)*nInfo) coerce !ℕ;
    
    (sharedInfo, noE) := computeSharedInfo(indices, bitsA, bitsB, nInfo, nSharedBits);  
    // computes the shared information obtained 
    // and the potential detection of an eavesdropper
    
    return (noE, nSharedBits); 
    // returns whether an eavesdropper was detected (0 if detection)
    // and how many bits of info are shared
}

/* TEST */

def testQKDnoE() { // tests QKD with no eavesdropper 
    n := 12;
    channel := λ(b:int[n]). b; // channel = id
    (noE, nSharedBits) := qkd[n](channel);
    assert(noE); // no detection of eavesdropper (noE=1)
    print(noE, nSharedBits);
}

def testQKDE() { // tests QKD with an eavesdropper 
    n := 12;
    channel := λ(b:int[n]){ for i in [0..n) {b[i] := H(b[i])}; return b; }; 
    // channel alters the qubits
    (noE, nSharedBits) := qkd[n](channel);
    print(noE, nSharedBits);
}

/* EXAMPLE CALL */

def main() {
    // tests QKD both with and without an eavesdropper
    
    // test without eavesdropper should always be of the form (1,n)
    testQKDnoE();

    // test with an eavesdropper may be of the form (0,n) if its presence is detected
    testQKDE(); 
}
// Random number generators

def uniformInt(range:!ℕ){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !ℕ;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}

// Shor code (Quantum error correction)
// - Returns the qubit ψ where ψ is encoded to a 9-qubit state and then  
// - passed through a noisy channel potentially altering the state of one of the qubits


// Helper function

def applyToEach[τ,τ'](triple:τ^3, f: τ !→ τ') { // apply a function to each element of a triple
    (h0,h1,h2) := triple;
    fTriple := (f(h0),f(h1),f(h2));

    return fTriple;
}


def triplicate(ψ:𝔹) mfree {  // entangle a qubit with two duplicates 
    ψ := (dup(ψ), dup(ψ), ψ);

    return ψ;
}

def encode(ψ:B) {  // encode a single qubit ψ into a 9-qubit state
    ψ := triplicate(ψ);
    ψ := applyToEach(ψ, H);
    ψ := applyToEach(ψ, triplicate);

    return ψ;
}

def correct(ψ:𝔹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    a1 := measure(ψ[0] ⊕ ψ[1]);
    a2 := measure(ψ[0] ⊕ ψ[2]);

    // apply the appropriate correction
    if (a1 && a2) {
        ψ[0] := X(ψ[0]);
    } else if (a1) {
        ψ[1] := X(ψ[1]);
    } else if (a2) {
        ψ[2] := X(ψ[2]);
    }

    return ψ;
}

def correctBitFlip(ψ:(B^3)^3) {  // correct a single bit-flip error in each triplet of a triplet of triplets
    ψ := applyToEach(ψ, correct);

    return ψ;
}

def correctPhaseFlip(ψ:(B^3)^3) { // correct a single phase-flip error
    ψ := applyToEach(ψ, reverse(triplicate));
    ψ := applyToEach(ψ, H);
    ψ := correct(ψ);

    return ψ
}

def shor_code(ψ:B,  channel: (B^3)^3 !→ (B^3)^3){ // simulate the Shor code error-correcting process
    ψ := encode(ψ);

    ψ := channel(ψ);

    ψ := correctBitFlip(ψ); 
    ψ := correctPhaseFlip(ψ);

    ψ := reverse(triplicate)(ψ);

    return ψ;
}

/* EXAMPLES */

def channel(ψ:(𝔹^3)^3) { // flip both one qubit and its phase in a 3x3 structure
    ψ[0][1] := Z(ψ[0][1]); 
    ψ[0][1] := X(ψ[0][1]); 
    return ψ; 
}

def main() {
    // Example 1: basis state
    ψ := 1:𝔹; 
    φ := shor_code(ψ, channel); 
    // verifies that φ = 1
    forget(φ=1);

    // Example 2: superposition
    ψ := H(1:𝔹); 
    φ := shor_code(ψ, channel); 
    // verifies that φ = H(|1>)
    return φ;
}// Simon's algorithm 

def main() {
  return Simon();
}

def Simon(){
  // Initializing Qubits for Inputs - a,b,c and Oracle - d,e,f
  a:=0:𝔹;
  b:=0:𝔹;
  c:=0:𝔹;
  d:=0:𝔹;
  e:=0:𝔹;
  f:=0:𝔹;

  // Applying Hadamard to Inputs
  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Encoding 011 secret key in the Oracle

  if b{
    d := X(d);
  }

  if b{
    e := X(e);
  }

  if c{
    d := X(d);
  }

  if b{
    f := X(f);
  }

  if c{
    e := X(e);
  }

  if c{
    f := X(f);
  }

  // Applying Hadamard to Inputs

  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Measure the d,e,f qubits for variable consumption

  md:=measure(d);
  me:=measure(e);
  mf:=measure(f);

  return (a,b,c,md,me,mf);
}def main() {
  return Hadamard();
}

def Hadamard() {
  x:=0:𝔹;
  return H(x);
}

def PauliZ() {
  z:=1:𝔹;
  return Z(z);
}

def PauliY() {
  y:=1:𝔹;
  return Y(y);
}

def PauliX() {
  x:=0:𝔹;
  return X(x);
}def main() {
  return SuperDenseCoding();
}

def SuperDenseCoding(){
  a:=0:𝔹;
  b:=0:𝔹;
  
  // Bell State Preparation
  a:=H(a);
  if a{
    b := X(b);
  }

  // Alice's Operation - 11 is sent
  a:=Z(a);
  a:=X(a);

  // Bob's Operation
  if a{
    b := X(b);
  }

  a:=H(a);

  return(a,b);
}// Superposition generation
// - Generates the (normalized) superposition |0⟩ + ... + |N-1⟩ on k qubits  
//  
// - Requires N < 2^k

def superposition[k:!ℕ](N:!ℕ, qs:𝔹^k)mfree:𝔹^k{ 
    // generates the (normalized) superposition |0⟩ + ... + |N-1⟩ on k qubits

    assert(N <= 2^k); 
    // ensures that the biggest state |N-1⟩ requires less than k qubits to be written
   
    n := floor(log(N)/log(2)) coerce !ℕ;
    r := N - 2^n coerce !ℕ;
    // decomposition N = 2^n + r

    // rotate first qubit
    (head,)~tail := qs; 
    θ := 2*asin(sqrt(r)/sqrt(N));
    // sin(θ/2) = sqrt(r/N), cos(θ/2) = sqrt((N-r)/N) = sqrt(2^n/N)
	
    head := rotY(θ, head); 
    // |0⟩ ↦ cos(θ/2)|0⟩ + sin(θ/2)|1⟩ = sqrt(2^n/N) |0⟩ + sqrt(r/N)|1⟩

    // state : 
    // (sqrt(2^n)/sqrt(N))|0⟩⊗(|0⟩⊗ ⋯ ⊗|0⟩) + (sqrt(r)/sqrt(N))|1⟩⊗(|0⟩⊗ ⋯ ⊗|0⟩)

    // conditionally on first qubit either prepare 
    // the uniform distribution on n qubits or 
    // (recursively) the remainder |0⟩ + ... + |r-1⟩
    if head {
        tail := superposition(r, tail); // (|0⟩ + ... + |r-1⟩)/sqrt(r)
    }
    else {
        for i in [0..n) { tail[i] := H(tail[i]); } // ∑ᵥ|v⟩/sqrt(2^n)
    }

    // tail = (x₁, ..., xₙ, xₙ₊₁, ..., xₖ) and 
    // head (= x₀) is the MSB of (x₁, ..., xₙ, x₀)
    for i in [0..n div 2) { (tail[i], tail[n-1-i]) := (tail[n-1-i], tail[i]); } 
    // tail = (xₙ, ..., x₁, xₙ₊₁, ..., xₖ)
    
    qs:=(head,)~tail;                                                           
    // qs = (x₀, xₙ, ..., x₁, xₙ₊₁, ..., xₖ)
    
    for i in [0..(n+1) div 2) { (qs[i], qs[n-i]) := (qs[n-i], qs[i]); }         
    // qs = (x₁, ..., xₙ, x₀, xₙ₊₁, ..., xₖ)

    // state :   
    // (sqrt(2^n)/sqrt(N))|0⟩⊗(∑ᵥ|v⟩/sqrt(2^n)) + 
    // (sqrt(r)/sqrt(N))|1⟩⊗((|0⟩ + ... + |r-1⟩)/sqrt(r)
    // = (1/sqrt(N))(|0⟩ + ... + |N-1⟩)

    return qs;
}

/* TEST */

def test_superposition() { 
    k := 5;
    qs := vector(k, 0:𝔹);
    qs := superposition(19, qs);
    measure(qs);
}

/* EXAMPLE CALL */

def main() {
    N := 19;
    // generates the normalized superposition |0⟩ + ... + |18⟩ on 5 qubits
    qs := superposition(N,  vector(5, 0:𝔹)) as uint[5];

    // measures 0 <= n < 19 
    n := measure(qs); 
    assert(n < N);
    return(n);
}def main() {
  return Teleportation();
}

def Teleportation(){

  // Initialize Qubits - 'a' qubit is to be teleported by Alice to Bob
  a:=0:𝔹;
  b:=0:𝔹;
  c:=0:𝔹;

  // Alice's Operations

  // Creating the Bell State
  b:=H(b);

  if b{
    c := X(c);
  }

  // Alice applies CX and H to 'a' qubit

  if a{
    b := X(b);
  }

  a:=H(a);

  // Alice measures her qubits 'a' and 'b'

  ma1:=measure(a);
  ma2:=measure(b);
  print(ma1);
  print(ma2);

  // Bob's measurement

  //c:=X(c);
  //c:=Z(c);

  return (c);
}def main() {
  return UniformSuperposition[1]();
}

def UniformSuperposition[n:!ℕ]():𝔹^n{
  qubits := vector(n,0:𝔹); // vector of length n filled with zeros
  for i in [0..n){
    qubits[i] := H(qubits[i]);
  }
  return qubits;
}