def main(){
    b:=1:𝔹;
    b:=H(b);

    c:=1:𝔹;
    if b{
        c:= X(c);
    }

    return (b,c);
}def main() {
  return BellState();
}

def BellState(){
  b:=1:𝔹;
  b:=H(b);
   
  c:=1:𝔹;
  if b{
    c := X(c);
  }

  return (b,c);

}// Bernstein-Vazirani algorithm
// - Returns s where f(x) = s·x mod 2
//

def bernstein_vazirani[n:!ℕ](f: const uint[n] !→ lifted 𝔹):!uint[n]{
  cand := 0:uint[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // ∑ᵥ|v⟩

  if f(cand) {
    phase(π);
  }

  // state ignoring normalization:
  //   ∑ᵥ(-1)^f(v)  |v⟩
  // = ∑ᵥ(-1)^(s·v) |v⟩
  // = (|0⟩+(-1)^(s₁)|1⟩) ⊗ ⋯ ⊗ (|0⟩+(-1)^(sₙ)|1⟩)

  for k in [0..n) { cand[k] := H(cand[k]); }

  s := measure(cand);
  return s;
}

/* TEST */

def f[n:!ℕ](s:!uint[n])(x:uint[n])lifted:𝔹{
  y := scal(s, x)%2;
  return y==1;
}

def scal[n:!ℕ](const x:uint[n], const y:uint[n])qfree:uint[n] { 
  // computes the scalar product x·y
  count := 0:uint[n];
  for k in [0..n) { 
    count+=x[k] && y[k];
  }
  return count;
}

def main() {
  // test  with all secret strings on 3 bits
  for i in [0..8) {
	  s := i coerce !uint[3];
	  s₀ := bernstein_vazirani(f(s));
	  assert(s==s₀);
  }

  // test with secret string s = 01
  s := 1 coerce !uint[2];
  s₀ := bernstein_vazirani(f(s));
  return s₀;

}
// Bernstein-Vazirani algorithm
// - Returns s where f(x) = s·x mod 2
//

def bernstein_vazirani[n:!ℕ](f: const uint[n] !→ lifted 𝔹):!uint[n]{
  cand := 0:uint[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // ∑ᵥ|v⟩

  if f(cand) {
    phase(π);
  }

  // state ignoring normalization:
  //   ∑ᵥ(-1)^f(v)  |v⟩
  // = ∑ᵥ(-1)^(s·v) |v⟩
  // = (|0⟩+(-1)^(s₁)|1⟩) ⊗ ⋯ ⊗ (|0⟩+(-1)^(sₙ)|1⟩)

  for k in [0..n) { cand[k] := H(cand[k]); }

  s := measure(cand);
  return s;
}

/* TEST */

def f[n:!ℕ](s:!uint[n])(x:uint[n])lifted:𝔹{
  y := scal(s, x)%2;
  return y==1;
}

def scal[n:!ℕ](const x:uint[n], const y:uint[n])qfree:uint[n] { 
  // computes the scalar product x·y
  count := 0:uint[n];
  for k in [0..n) { 
    count+=x[k] && y[k];
  }
  return count;
}

def main() {
  // test  with all secret strings on 3 bits
  for i in [0..8) {
	  s := i coerce !uint[3];
	  s₀ := bernstein_vazirani(f(s));
	  assert(s==s₀);
  }

  // test with secret string s = 01
  s := 1 coerce !uint[2];
  s₀ := bernstein_vazirani(f(s));
  return s₀;

}



// Bit-Flip code (Quantum error correction)
// - Returns the qubit ψ where ψ is encoded to a 3-qubit state and then  
// - passed through a noisy channel potentially flipping one of the qubits


def encode(ψ:𝔹) mfree { // encode a single qubit ψ into a 3-qubit state
    ψ := (dup(ψ), dup(ψ), ψ);
    
    return ψ;
}

def correct(ψ:𝔹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    p1 := measure(ψ[0] ⊕ ψ[1]);
    p2 := measure(ψ[0] ⊕ ψ[2]);

    // apply the appropriate correction
    if (p1 && p2) {
        ψ[0] := X(ψ[0]);
    } else if (p1) {
        ψ[1] := X(ψ[1]);
    } else if (p2) {
        ψ[2] := X(ψ[2]);
    }

    return ψ;
}

def bit_flip_code(ψ: 𝔹, channel: 𝔹^3 !→ 𝔹^3) { // simulate the bit-flip code error-correcting process
    ψ := encode(ψ);
    ψ := channel(ψ);
    ψ := correct(ψ);
    ψ := reverse(encode)(ψ);

    return ψ;
}

/* EXAMPLES */

def channel(ψ:𝔹^3) { // flip the first qubit of a 3-qubit state
    ψ[0] := X(ψ[0]);
    return ψ;
}

def main() {
    // Example 1: basis state
    ψ := 1:𝔹; 
    φ := bit_flip_code(ψ, channel); 
    // verifies that φ = 1
    forget(φ = 1);

    // Example 2: superposition
    ψ := H(1:𝔹); 
    φ := bit_flip_code(ψ, channel); 
    // verifies that φ = H(|1>)
    return φ;
}


def main(){
    return CCX(1:𝔹,1:𝔹,1:𝔹);
}

def CCX(const x:𝔹,const y:𝔹,z:𝔹):𝔹
{
    if x && y{
        z:=X(z);
    }

    return (z);
}def main(){
    return CX(1:𝔹, 0:𝔹);
}


def CX(const x:𝔹, y:𝔹):𝔹{
    if x{
        y:=X(y);
    }
    return y;
}def main(){
    return CSWAP(1:𝔹,0:𝔹,1:𝔹);
}

def CSWAP(x:𝔹,y:𝔹,z:𝔹){
    if x{
        a:=z;
        z:=y;
        y:=a;
    }

    return (x,y,z);
}def main() {
    return CZ(1:𝔹,1:𝔹);

}

def CZ(const x:𝔹,y:𝔹):𝔹{
    if x{
        y:=Z(y);
    }

    return y;
}def main() {
  return DecomposedCX();
}

def DecomposedCX(){
  b:=1:𝔹;
  b:=H(b);

  a:=1:𝔹;
  if a{
    b := Z(b);
  }

  b:=H(b);

  return b;
}def main(){
    return DecomposedCX();
}

def DecomposedCX(){
    b:=1:𝔹;
    b:=H(b);
    a:=1:𝔹;
    if a{
        b:=Z(b);

    }
    b:=H(b);
    return b;
}// Deutsch-Jozsa algorithm 
// - Returns : | 0 if f is balanced (#{x, f(x)=0} = #{x, f(x)=1})
//             | 1 if f is constant (∀x f(x)=0 or ∀x f(x)=1)


def deutsch_jozsa[n:!ℕ](f: const int[n] !→ lifted 𝔹):!𝔹{
  cand := 0:int[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // ∑ᵥ|v⟩

  if f(cand) {
	  phase(π);
  }

  // state ignoring normalization:
  // ∑ᵥ(-1)^f(v)|v⟩

  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  //   ∑ᵥ(-1)^f(v) ∑ᵤ (-1)^(u·v)|u⟩  

  result := measure(cand);
  // probability to measure 0 is:
  // - 1 if f constant (constructive interference) 
  // - 0 if f balanced (destructive interference)
  return result==0;
}

/* TEST */

def test_balanced() {
  def balanced(x:int[2])lifted:𝔹{
    if (x[0]==1) { 
      return 1:𝔹;
    }
    else {
      return 0:𝔹;
    }
  } // implements a balanced function (outputs half 0 and half 1)
  x := deutsch_jozsa(balanced);
  assert(x == 0); 
  return x;
}

def test_constant() {
  def constant(x:int[2])lifted:𝔹{
    return 1:𝔹;
  } // implements a constant function (outputs only 1)
  x := deutsch_jozsa(constant);
  assert(x == 1);
  return x;
}

def main() {
  print(test_balanced()); // DJ on balanced function should output 0
  print(test_constant()); // DJ on constant function should output 1
  return;
}// Deutsch-Jozsa algorithm 
// - Returns : | 0 if f is balanced (#{x, f(x)=0} = #{x, f(x)=1})
//             | 1 if f is constant (∀x f(x)=0 or ∀x f(x)=1)


def deutsch_jozsa[n:!ℕ](f: const int[n] !→ lifted 𝔹):!𝔹{
  cand := 0:int[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // ∑ᵥ|v⟩

  if f(cand) {
	  phase(π);
  }

  // state ignoring normalization:
  // ∑ᵥ(-1)^f(v)|v⟩

  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  //   ∑ᵥ(-1)^f(v) ∑ᵤ (-1)^(u·v)|u⟩  

  result := measure(cand);
  // probability to measure 0 is:
  // - 1 if f constant (constructive interference) 
  // - 0 if f balanced (destructive interference)
  return result==0;
}

/* TEST */

def test_balanced() {
  def balanced(x:int[2])lifted:𝔹{
    if (x[0]==1) { 
      return 1:𝔹;
    }
    else {
      return 0:𝔹;
    }
  } // implements a balanced function (outputs half 0 and half 1)
  x := deutsch_jozsa(balanced);
  assert(x == 0); 
  return x;
}

def test_constant() {
  def constant(x:int[2])lifted:𝔹{
    return 1:𝔹;
  } // implements a constant function (outputs only 1)
  x := deutsch_jozsa(constant);
  assert(x == 1);
  return x;
}

def main() {
  print(test_balanced()); // DJ on balanced function should output 0
  print(test_constant()); // DJ on constant function should output 1
  return;
}
def main() {
  x:=0:𝔹;
  return H(x);
}def geometric():!ℕ{
    count := 0;
    ok := true;
    while ok{
        count += 1;
        ok = measure(H(false));
    }
    return count;
}

def main() {
    return geometric();
}def main() {
  return geometric();
}

def geometric():!ℕ{
    count := 0;
    ok := true;
    while ok{
        count += 1;
        ok = measure(H(false));
    }
    return count;
}def main(){
    return GHZ();
}

def GHZ(){
    a:=0:𝔹;
    b:=0:𝔹;
    c:=0:𝔹;
    a:=H(a);
    if a{
        b:= X(b);
    }
    if b{
        c:= X(c);

    }
    return (a,b,c);
}def main() {
  return GHZ();
}

def GHZ(){
  a:=0:𝔹;
  b:=0:𝔹;
  c:=0:𝔹;

  a:=H(a);

  if a{
    b := X(b);
  }

  if b{
    c := X(c);
  }

  return (a,b,c);

}// Grover's algorithm for an unknown number of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/pdf/1709.01236.pdf


// Random number generators

def uniformInt(range:!ℕ){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !ℕ;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}



// Grover Diffusion Operator

def groverDiffusion[n:!ℕ](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(π); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}

def grover_unknown[n:!ℕ](f: const uint[n] !→ lifted 𝔹):!ℕ{
	m := 1:!ℚ;
	l := 6/5;

	while (m <= 2^(n/2)) {
		nIterations := uniformInt(floor(m) coerce !ℕ) + 1;
		
		cand := 0:uint[n];
    	for k in [0..n) {cand[k] := H(cand[k]);}
		
		for k in [0..nIterations){
			if f(cand){
				phase(π);
			}
		cand:=groverDiffusion(cand);
		}

		x := measure(cand);

		if f(x) {return x as !ℕ;}
		else {m=l*m;}
	}

	return 0;
}

/* EXAMPLE CALL */

def main(){
	f := λ(x:uint[5])lifted:𝔹{ return x==1 || x==2 || x==5 || x==8; }; 
	// creates an oracle which outputs one only when x is in {1,2,5,8}
	
	x := grover_unknown(f); 
	
	assert(x==1 || x==2 || x==5 || x==8); 
	// verifies that grover_unknown finds one of the right solutions

	return x;
}



/* TEST */ 

// This function defines tests for Grover with respectively 1, 2, 3 and 4 solutions
def test_grover_unknown() {
	n := 5;
	def f1(x:uint[n])lifted:𝔹{
    	return x==1;
	}
	def f2(x:uint[n])lifted:𝔹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:𝔹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:𝔹{
    	return x==7 || x==8 || x==9 || x==10;
	}
	 // creates oracles with respectively 1, 2, 3 and 4 solutions
	x := grover_unknown(f1);
	y := grover_unknown(f2);
	z := grover_unknown(f3);
	w := grover_unknown(f4);
	// verifies that grover_unknown finds one of the right solutions
	assert(x==1);
	assert(y==2 || y==3);
	assert(z==4 || z==5 || z==6);
	assert(w==7 || w==8 || w==9 || w==10);
}
// Grover's algorithm for a known number (M) of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/ftp/arxiv/papers/0705/0705.4171.pdf

// Grover Diffusion Operator

def groverDiffusion[n:!ℕ](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(π); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}
// Random number generators

def uniformInt(range:!ℕ){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !ℕ;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}


def grover_multiple[n:!ℕ](f: const uint[n] !→ lifted 𝔹, M:!ℕ):!ℕ{
	nIterations:= round((π/4) * sqrt(2^n/M));
	cand:=0:uint[n];
    for k in [0..n) { cand[k] := H(cand[k]); }
	
	for k in [0..nIterations){
		if f(cand){
			phase(π);
		}
		cand:=groverDiffusion(cand);
	}
	return measure(cand) as !ℕ;
}

/* EXAMPLE CALL */

def main(){
	f := λ(x:uint[6])lifted:𝔹{ return x==4 || x==5 || x==6; }; 
	// creates an oracle which outputs one only when x is in {4,5,6}
	
	x := grover_multiple(f, 3); 
	
	assert(x==4 || x==5 || x==6); 
	// verifies that grover_multiple finds one of the right solutions

	return x;
}

/* TEST */

// This function defines tests for Grover with respectively 2, 3 and 4 solutions
def test_grover_multiple() {
	n := 6;
	def f2(x:uint[n])lifted:𝔹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:𝔹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:𝔹{
    	return x==7 || x==8 || x==9 || x==10;
	} // creates oracles with respectively 2, 3 and 4 solutions
	x := grover_multiple(f2, 2);
	y := grover_multiple(f3, 3);
	z := grover_multiple(f4, 4);
	// verifies that grover_multiple finds one of the right solutions
	assert(x==2 || x==3);
	assert(y==4 || y==5 || y==6);
	assert(z==7 || z==8 || z==9 || z==10);
}
def groverDiff[n:!N](cand:uint[n]){
  for k in [0..n) {
        cand[k]:= H(cand[k]);
        cand[k]:= X(cand[k]);

    }
   if (cand=3){phase(π);}
   for k in [0..n) {
        cand[k]:= X(cand[k]);
        cand[k]:= H(cand[k]);

   }
   return cand;
}
def grover[n:!N](f:const uint[n]!->qfree B){
    nInteration := 1;
    cand := 0:uint[n];
    for k in [0..n) {
        cand[k]:= H(cand[k]);
    }
   // dump();
    for k in [0..nInteration){
        if (f(cand)){phase(π);}
        cand := groverDiff[n](cand);
    }
    dump();
    return measure(cand);
}
//Oracle
def f[n:!N](const cand:uint[n])qfree:B {
    return cand=2 || cand=3;
}
def main(){
    n := 3:!N;
    //dump();
    m := grover[n](f[n]);
   // dump();
}// Grover Diffusion Operator

def groverDiffusion[n:!ℕ](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(π); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}
// Grover's algorithm for a known number (M) of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/ftp/arxiv/papers/0705/0705.4171.pdf


import helpers.groverDiffusion;

def grover_multiple[n:!ℕ](f: const uint[n] !→ lifted 𝔹, M:!ℕ):!ℕ{
	nIterations:= round((π/4) * sqrt(2^n/M));
	cand:=0:uint[n];
    for k in [0..n) { cand[k] := H(cand[k]); }
	
	for k in [0..nIterations){
		if f(cand){
			phase(π);
		}
		cand:=groverDiffusion(cand);
	}
	return measure(cand) as !ℕ;
}

/* EXAMPLE CALL */

def main(){
	f := λ(x:uint[6])lifted:𝔹{ return x==4 || x==5 || x==6; }; 
	// creates an oracle which outputs one only when x is in {4,5,6}
	
	x := grover_multiple(f, 3); 
	
	assert(x==4 || x==5 || x==6); 
	// verifies that grover_multiple finds one of the right solutions

	return x;
}

/* TEST */

// This function defines tests for Grover with respectively 2, 3 and 4 solutions
def test_grover_multiple() {
	n := 6;
	def f2(x:uint[n])lifted:𝔹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:𝔹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:𝔹{
    	return x==7 || x==8 || x==9 || x==10;
	} // creates oracles with respectively 2, 3 and 4 solutions
	x := grover_multiple(f2, 2);
	y := grover_multiple(f3, 3);
	z := grover_multiple(f4, 4);
	// verifies that grover_multiple finds one of the right solutions
	assert(x==2 || x==3);
	assert(y==4 || y==5 || y==6);
	assert(z==7 || z==8 || z==9 || z==10);
}



// Grover's algorithm for a single solution
// - Returns the only x for which f(x) = 1
//
// - More detailed description: https://www.scottaaronson.com/qclec/22.pdf

import helpers.groverDiffusion;

def grover[n:!ℕ](f: const uint[n] !→ lifted 𝔹):!ℕ{ 
	nIterations:= round(π / 4 * sqrt(2^n));
	cand:=0:uint[n];
    for k in [0..n) {cand[k] := H(cand[k]);} 
	
	for k in [0..nIterations){
		if f(cand){
			phase(π);
		}		
		// state ignoring normalization:   
    	// ∑(v≠w)|v⟩ - |w*⟩
		cand:=groverDiffusion(cand);  
    	// ∑(v≠w)γ₋|v⟩ + γ₊|w*⟩
	}
	return measure(cand) as !ℕ;
}

/* EXAMPLE CALL */

def main() {
	f := λ(x:uint[5])lifted:𝔹{return x==3;}; // creates an oracle which outputs one only when x=3
	x := grover(f); 
	assert(x==3); // verifies that grover finds the right solution

	return x;
}

/* TEST */ 

// This function defines a test for Grover
def test_grover() {
	def f(x:uint[3])lifted:𝔹{
    	return x==7;
	} // creates an oracle which outputs one only when x=3
	x := grover(f);
	// verifies that grover finds the right solution
	assert(x==7);

	return x;
}


// Grover's algorithm for a single solution
// - Returns the only x for which f(x) = 1
//
// - More detailed description: https://www.scottaaronson.com/qclec/22.pdf


def grover[n:!ℕ](f: const uint[n] !→ lifted 𝔹):!ℕ{ 
	nIterations:= round(π / 4 * sqrt(2^n));
	cand:=0:uint[n];
    for k in [0..n) {cand[k] := H(cand[k]);} 
	
	for k in [0..nIterations){
		if f(cand){
			phase(π);
		}		
		// state ignoring normalization:   
    	// ∑(v≠w)|v⟩ - |w*⟩
		cand:=groverDiffusion(cand);  
    	// ∑(v≠w)γ₋|v⟩ + γ₊|w*⟩
	}
	return measure(cand) as !ℕ;
}

/* EXAMPLE CALL */

def main() {
	f := λ(x:uint[5])lifted:𝔹{return x==3;}; // creates an oracle which outputs one only when x=3
	x := grover(f); 
	assert(x==3); // verifies that grover finds the right solution

	return x;
}

// Grover Diffusion Operator

def groverDiffusion[n:!ℕ](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(π); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}


/* TEST */

// Random number generators

def uniformInt(range:!ℕ){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !ℕ;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}



// This function defines a test for Grover
def test_grover() {
	def f(x:uint[3])lifted:𝔹{
    	return x==7;
	} // creates an oracle which outputs one only when x=3
	x := grover(f);
	// verifies that grover finds the right solution
	assert(x==7);

	return x;
}// Grover's algorithm for an unknown number of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/pdf/1709.01236.pdf

import helpers.groverDiffusion;
import helpers.rand;

def grover_unknown[n:!ℕ](f: const uint[n] !→ lifted 𝔹):!ℕ{
	m := 1:!ℚ;
	l := 6/5;

	while (m <= 2^(n/2)) {
		nIterations := uniformInt(floor(m) coerce !ℕ) + 1;
		
		cand := 0:uint[n];
    	for k in [0..n) {cand[k] := H(cand[k]);}
		
		for k in [0..nIterations){
			if f(cand){
				phase(π);
			}
		cand:=groverDiffusion(cand);
		}

		x := measure(cand);

		if f(x) {return x as !ℕ;}
		else {m=l*m;}
	}

	return 0;
}

/* EXAMPLE CALL */

def main(){
	f := λ(x:uint[5])lifted:𝔹{ return x==1 || x==2 || x==5 || x==8; }; 
	// creates an oracle which outputs one only when x is in {1,2,5,8}
	
	x := grover_unknown(f); 
	
	assert(x==1 || x==2 || x==5 || x==8); 
	// verifies that grover_unknown finds one of the right solutions

	return x;
}



/* TEST */ 

// This function defines tests for Grover with respectively 1, 2, 3 and 4 solutions
def test_grover_unknown() {
	n := 5;
	def f1(x:uint[n])lifted:𝔹{
    	return x==1;
	}
	def f2(x:uint[n])lifted:𝔹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:𝔹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:𝔹{
    	return x==7 || x==8 || x==9 || x==10;
	}
	 // creates oracles with respectively 1, 2, 3 and 4 solutions
	x := grover_unknown(f1);
	y := grover_unknown(f2);
	z := grover_unknown(f3);
	w := grover_unknown(f4);
	// verifies that grover_unknown finds one of the right solutions
	assert(x==1);
	assert(y==2 || y==3);
	assert(z==4 || z==5 || z==6);
	assert(w==7 || w==8 || w==9 || w==10);
}



def main(){
    return Hadamard();
}

def Hadamard(){
    x:=0:𝔹;
    return H(x);
}def main(){
    return HalfAdder();
}

def HalfAdder(){
    //Define 4 Qubits - a & b inputs, s & c are sum and carry -
    // outputs

    a:=1:𝔹;
    b:=1:𝔹;
    s:=0:𝔹;
    c:=0:𝔹;
    // XOR Gate Operation
    // CX operation on b and s qubit
    if b{
        s:=X(s);
    }
    // CX operation on a and s
    if a{
        s:= X(s);

    }
    // AND Gate Operation
    if a && b{
        c:= X(c);
    }

    return (s,c);

}def main() {
  return HalfAdder();
}

def HalfAdder(){
  // Define 4 Qubits - a & b inputs, s & c are sum and carry - outputs
  a:=1:𝔹;
  b:=1:𝔹;
  s:=0:𝔹;
  c:=0:𝔹;

  // XOR Gate Operation

  // CX operation on b and s qubit
  if b{
    s := X(s);
  }
  
  // CX operation on a and s
  if a{
    s := X(s);
  }

  // AND Gate Operation

  if a && b{
    c := X(c);
  }

  return (s,c);
}def CSWAP(x:𝔹, y:𝔹, z:𝔹) {
  if x{
    a:=z;
    z:=y;
    y:=a;
  }
  return (x,y,z);
}

def SWAP(x:𝔹, y:𝔹) {
  a:=y;
  y:=x;
  x:=a;
  return (x,y);
}

def CCX(const x:𝔹,const y:𝔹,z:𝔹):𝔹{
  if x && y{
    z := X(z);
  }
  return (z);
}

def CZ(const x:𝔹,y:𝔹):𝔹{
  if x{
    y := Z(y);
  }
  return y;
}

def CX(const x:𝔹,y:𝔹):𝔹{
  if x{
    y := X(y);
  }
  return y;
}def main() {
    return PauliX();
}

def PauliX(){
    x:=0:𝔹;
    return X(x);
}def main() {
    return PauliY();
}

def PauliY(){
    y:=1:𝔹;
    return Y(y);
}def main(){
    return PauliZ();
}

def PauliZ(){
    z:=1:𝔹;
    return Z(z);
}

// Phase Estimation algorithm

import qft;

def phaseEstimation[k:!ℕ](
    U:int[k] !->mfree int[k],
    u:int[k], 
    precision:!ℕ) {

    ancilla := 0:int[precision];
    for i in [0..precision) { ancilla[i] := H(ancilla[i]); }

    for i in [0..precision) { 
        if ancilla[i] {
            for l in [0..2^i) {
                u := U(u);
            }
        }
    }

    ancilla := reverse(QFT[precision])(ancilla);
    result := measure(ancilla);
    measure(u);
    return result;
}
// Phase-Flip code (Quantum error correction)
// - Returns the qubit ψ where ψ is encoded to a 3-qubit state and then  
// - passed through a noisy channel potentially flipping the phase of one of the qubits


def encode(ψ:𝔹) mfree { // encode a single qubit ψ into a 3-qubit state
    ψ := (dup(ψ), dup(ψ), ψ);
    
    return ψ;}

def correct(ψ:𝔹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    p1 := measure(ψ[0] ⊕ ψ[1]);
    p2 := measure(ψ[0] ⊕ ψ[2]);

    // apply the appropriate correction
    if (p1 && p2) {
        ψ[0] := X(ψ[0]);
    } else if (p1) {
        ψ[1] := X(ψ[1]);
    } else if (p2) {
        ψ[2] := X(ψ[2]);
    }

    return ψ;
}

def phase_flip_code(ψ: 𝔹, channel: 𝔹^3 !→ 𝔹^3) { // simulate the phase-flip code error-correcting process
    ψ := encode(ψ);

    for k in [0..3) {ψ[k] := H(ψ[k]);}
    ψ := channel(ψ);
    for k in [0..3) {ψ[k] := H(ψ[k]);}

    ψ := correct(ψ);
    ψ := reverse(encode)(ψ);

    return ψ;
}

/* EXAMPLES */

def channel(ψ:𝔹^3) { // flip the phase of the second qubit of a 3-qubit state
    ψ[1] := Z(ψ[1]);
    return ψ;
}

def main() {
    // Example 1: basis state
    ψ := 0:𝔹; 
    φ := phase_flip_code(ψ, channel); 
    // verifies that φ = 0
    forget(φ = 0);

    // Example 2: superposition
    ψ := H(0:𝔹); 
    φ := phase_flip_code(ψ, channel); 
    // verifies that φ = H(|0>)
    return φ;
}


// Quantum Fourier Transform


def QFT[n:!ℕ](ψ: int[n])mfree: int[n]{
	for k in [0..n div 2){
		(ψ[k],ψ[n-k-1]) := (ψ[n-k-1],ψ[k]);
	}
	for k in [0..n){
		ψ[k] := H(ψ[k]);
		for l in [k+1..n){
			if ψ[l] && ψ[k]{
				phase(2*π * 2^(k-l-1));
			}
		}
	}
	return ψ;
}


def main(){
	ψ := 2:int[2];
	return QFT(ψ);
}
def QFT[n:!N] (qs:B^n) mfree:B^n {
    for i in [0..n) {
        qs[i] := H(qs[i]);

        for j in [i+1..n) {
            qs[j] := U1(π/2^(j - i), qs[j]);
        }
    }

    return swap_all(qs);
}
def swap_all[n:!N] (qs:B^n) mfree:B^n {
    for i in [0..n div 2) {
      (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
    }

    return qs;
}
// Single-qubit rotation about the Z axis.
def U1 (r:!ℝ, q:B) mfree {
    if q { phase(r) }
    return q;
}



def QFT[n:!N] (qs:B^n) mfree:B^n { // 量子傅立叶变换函数
    for i in [0..n) {
        qs[i] := H(qs[i]); // 对每个量子比特应用哈密顿门
        for j in [i+1..n) {
            qs[j] := U1(π/2^(j - i), qs[j]); // 应用CNOT门
        }
    }
    
    return swap_all(qs); // 交换所有量子比特
}

def swap_all[n:!N] (qs:B^n) mfree:B^n { // 交换函数
    for i in [0..n div 2) { // 交换相邻的量子比特
      (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
    }

    return qs;
}

// 单比特绕z轴旋转
def U1 (r:!ℝ, q:B) mfree { // 单个量子比特绕Z轴旋转
    if q { phase(r) }
    return q;
}








def QFT[n:!N] (qs:B^n) mfree:B^n { // Quantum Fourier Transform Function
    for i in [0..n) {
        qs[i] := H(qs[i]); // Apply Hadamard gate on each qubit

        for j in [i+1..n) {
            qs[j] := U1(π/2^(j - i), qs[j]); // Apply Cnot gates
        }
    }
    
    return swap_all(qs); // Swap all qubits back in an order
}

def swap_all[n:!N] (qs:B^n) mfree:B^n { // Swap Function
    for i in [0..n div 2) { // Swap adjacent qubits 
      (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
    }

    return qs;
}

// Single-qubit rotation about the Z axis.
def U1 (r:!ℝ, q:B) mfree { // Rotation about the Z axis of a single qubit
    if q { phase(r) }
    return q;
}





// def QFT[n:!N] (qs:B^n) mfree:B^n {
//     for i in [0..n) {
//         qs[i] := H(qs[i]);

//         for j in [i+1..n) {
//             qs[j] := U1(π/2^(j - i), qs[j]);
//         }
//     }

//     return swap_all(qs);
// }
// def swap_all[n:!N] (qs:B^n) mfree:B^n {
//     for i in [0..n div 2) {
//       (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
//     }

//     return qs;
// }
// def U1 (r:!ℝ, q:B) mfree {
//     if q { phase(r) }
//     return q;
// }




// 定义一个用于执行量子傅里叶变换的函数
// [n:!N]定义类型参数，!N=内置类型参数限制=非负整数类型, [n:!N]=n是一个非负整数类型
// (qs:B^n) 定义函数参数，
def QFT[n:!N] (qs:B^n) mfree:B^n {
    // 对每个比特串应用Hadamard门
    for i in [0..n) {        qs[i] := H(qs[i]);

        // 对比特串进行相位旋转操作
        for j in [i+1..n) {            qs[j] := U1(π/2^(j - i), qs[j]);
        }
    }

    // 执行比特串的位翻转操作
    return swap_all(qs);
}

// 定义一个用于执行比特串的位翻转操作的函数
def swap_all[n:!N] (qs:B^n) mfree:B^n {
    // 对比特串进行位翻转操作
    for i in [0..n div 2) {      (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
    }

    return qs;
}

// 定义一个执行相位旋转操作的函数
def U1 (r:!ℝ, q:B) mfree {
    // 如果比特串的值为1，就对其进行相位旋转
    if q { phase(r) }
    return q;
}
def QFT[n:!N](x: int[n])mfree: int[n]{
	for k in [0..n div 2){
		(x[k],x[n-k-1]) := (x[n-k-1],x[k]);
	} //SWAP
	for k in [0..n){
		x[k] := H(x[k]);
		for l in [k+1..n){
			if x[l] && x[k]{
				phase(2*π * 2^(k-l-1));
			}
		}
	} //Superposition using H Gate and applying controlled RZ Gate
	return x;
}
//Missing Method to Check If Correct


// Quantum Key Distribution 
// - Simulates the generation of a secure key through an insecure channel


// Helper functions

// Returns 0 or 1 with equal probability
def rand(){
    return measure(H(false));
}

// Random number generator
def uniformInt(range:!ℕ){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !ℕ;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def prepareState(n:!ℕ) { 
    // prepares n random bits each encoded as a qubit in a random base 
    bitsA := 0:!int[n];
    basesA := 0:!int[n];
    
    for i in [0..n){ // generates random bits and random bases
	bitsA[i] = rand();
        basesA[i] = rand();
    }

    qubitsA := bitsA:int[n];
    for i in [0..n){ // encodes each qubit to be sent in the corresponding base
        if basesA[i] {qubitsA[i] = H(qubitsA[i]);}
    }

    return(bitsA, basesA, qubitsA);
}

def measureB[n:!ℕ](qubitsA:int[n]) { 
    // generates n random bases to measure the received bits
    basesB := 0:!int[n];
    
    for i in [0..n){ // generates random bases
        basesB[i] = rand();
    }

    for i in [0..n){ // decodes each received qubit according to the bases
        if basesB[i] {qubitsA[i] := H(qubitsA[i]);}
    }
    bitsB := measure(qubitsA);
    return (bitsB, basesB);
}

def compareBases[n:!ℕ](basesA:!int[n], basesB:!int[n]) { 
    // returns the correctly guessed bases
    indices := 0:!int[n];
    nInfo := 0:!ℕ;
    indices = ~(basesA ⊕ basesB); // keeps indices where bases coincide
    for i in [0..n){ 
        nInfo+=indices[i];
    }
    return (indices, nInfo);
}

def computePresumablySharedInfo[n:!ℕ](indices:!int[n], bitsA:!int[n], 
                                bitsB:!int[n], nInfo:!ℕ) {

    infoA := 0:!int[nInfo]; // contains the presumbaly shared information on A part
    infoB := 0:!int[nInfo];
    count := 0:!ℕ;
    i := 0:!ℕ;
    while (count < nInfo) { // computes the presumably shared information
        if indices[i] {
            infoA[count] = bitsA[i];
            infoB[count] = bitsB[i];            
            count+=1;
        }
        i+=1;
    }
    return (infoA, infoB);
}

def checkEavesdropper[n:!ℕ](infoA:!int[n], 
                            infoB:!int[n],
                            nSharedBits:!ℕ) {
    bitsRevealed := 0:!ℕ;
    noE := true;
    count := 0:!ℕ;
    i := 0:!ℕ;
    notAlreadyChecked := 2^n - 1 coerce !int[n];
    while (bitsRevealed < n - nSharedBits) { 
    // checks that no eavesdropper has gained info about the shared secret  
    // by comparing some bits
        i = uniformInt(n);
        if notAlreadyChecked[i] {
            // checks that random bits coincide
            noE &= (infoA[i] == infoB[i]);
            notAlreadyChecked[i] = false;
            bitsRevealed+=1;
        }
    }
    return (notAlreadyChecked, noE);
}

def computeSharedInfo[n:!ℕ](indices:!int[n], bitsA:!int[n], 
                            bitsB:!int[n], nInfo:!ℕ, nSharedBits:!ℕ) { 
    // computes shared information
    
    // nSharedBits is the number of remaining bits after 'burning' some of them 
    // to detect the presence of an eavesdropper
    assert (nSharedBits < nInfo);

    (infoA, infoB) := computePresumablySharedInfo(indices, bitsA, bitsB, nInfo);

    (notAlreadyChecked, noE) := checkEavesdropper(infoA, infoB, nSharedBits);

    sharedInfo := 0:!uint[nSharedBits]; 
    // contains the shared information to be used if no eavesdroper has been detected
    
    count := 0:!ℕ;
    i := 0:!ℕ;
    while (count < nSharedBits) { // computes the shared information
        if notAlreadyChecked[i] {
            sharedInfo[count] = infoA[i];
            count+=1;
        }
        i+=1;
    }

    return (sharedInfo, noE); 
    // returns the shared information and the detection or not of an eavesdropper
}

def qkd[n:!ℕ](channel: int[n] !→ int[n]){
    (bitsA, basesA, qubitsA) := prepareState(n); 
    // prepares the random bases and bits and the qubits to be send to B

    qubitsA := channel(qubitsA); 
    // simulates the transfer through a potentially malicious channel 

    (bitsB, basesB) := measureB(qubitsA); 
    // generates the guesses from B

    (indices, nInfo) := compareBases(basesA, basesB); 
    // compares the bases between A and B


    nSharedBits := floor((2/3)*nInfo) coerce !ℕ;
    
    (sharedInfo, noE) := computeSharedInfo(indices, bitsA, bitsB, nInfo, nSharedBits);  
    // computes the shared information obtained 
    // and the potential detection of an eavesdropper
    
    return (noE, nSharedBits); 
    // returns whether an eavesdropper was detected (0 if detection)
    // and how many bits of info are shared
}

/* TEST */

def testQKDnoE() { // tests QKD with no eavesdropper 
    n := 12;
    channel := λ(b:int[n]). b; // channel = id
    (noE, nSharedBits) := qkd[n](channel);
    assert(noE); // no detection of eavesdropper (noE=1)
    print(noE, nSharedBits);
}

def testQKDE() { // tests QKD with an eavesdropper 
    n := 12;
    channel := λ(b:int[n]){ for i in [0..n) {b[i] := H(b[i])}; return b; }; 
    // channel alters the qubits
    (noE, nSharedBits) := qkd[n](channel);
    print(noE, nSharedBits);
}

/* EXAMPLE CALL */

def main() {
    // tests QKD both with and without an eavesdropper
    
    // test without eavesdropper should always be of the form (1,n)
    testQKDnoE();

    // test with an eavesdropper may be of the form (0,n) if its presence is detected
    testQKDE(); 
}
def main(){
    return CX(1:𝔹,0:𝔹);
}

def CX(const x:𝔹,y:𝔹):𝔹{
    if x{
        y:= X(y);
    }

    return y;
}def main(){
    return Teleportation();
}

def Teleportation(){
    // Initialize Qubits - 'a' qubit is to be teleported by Alice
    // to Bob
    a:=0:𝔹;
    b:=0:𝔹;
    c:=0:𝔹;
    // Alice's Operations
    // Creating the Bell State
    b:=H(b);
    if b{
        c:=X(c);
    }

    //Alice applies CX and H to 'a' qubit
    if a{
        b:= X(b);
    }
    a:=H(a);
    // Alice measures her qubits 'a' and 'b'
    ma1:=measure(a);
    ma2:=measure(b);
    print(ma1);
    print(ma2);
    //Bob's measurement
    //c:=Z(c);
    //c:X(c);
    return (c);
}// Random number generators

def uniformInt(range:!ℕ){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !ℕ;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}

// Shor code (Quantum error correction)
// - Returns the qubit ψ where ψ is encoded to a 9-qubit state and then  
// - passed through a noisy channel potentially altering the state of one of the qubits


// Helper function

def applyToEach[τ,τ'](triple:τ^3, f: τ !→ τ') { // apply a function to each element of a triple
    (h0,h1,h2) := triple;
    fTriple := (f(h0),f(h1),f(h2));

    return fTriple;
}


def triplicate(ψ:𝔹) mfree {  // entangle a qubit with two duplicates 
    ψ := (dup(ψ), dup(ψ), ψ);

    return ψ;
}

def encode(ψ:B) {  // encode a single qubit ψ into a 9-qubit state
    ψ := triplicate(ψ);
    ψ := applyToEach(ψ, H);
    ψ := applyToEach(ψ, triplicate);

    return ψ;
}

def correct(ψ:𝔹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    a1 := measure(ψ[0] ⊕ ψ[1]);
    a2 := measure(ψ[0] ⊕ ψ[2]);

    // apply the appropriate correction
    if (a1 && a2) {
        ψ[0] := X(ψ[0]);
    } else if (a1) {
        ψ[1] := X(ψ[1]);
    } else if (a2) {
        ψ[2] := X(ψ[2]);
    }

    return ψ;
}

def correctBitFlip(ψ:(B^3)^3) {  // correct a single bit-flip error in each triplet of a triplet of triplets
    ψ := applyToEach(ψ, correct);

    return ψ;
}

def correctPhaseFlip(ψ:(B^3)^3) { // correct a single phase-flip error
    ψ := applyToEach(ψ, reverse(triplicate));
    ψ := applyToEach(ψ, H);
    ψ := correct(ψ);

    return ψ
}

def shor_code(ψ:B,  channel: (B^3)^3 !→ (B^3)^3){ // simulate the Shor code error-correcting process
    ψ := encode(ψ);

    ψ := channel(ψ);

    ψ := correctBitFlip(ψ); 
    ψ := correctPhaseFlip(ψ);

    ψ := reverse(triplicate)(ψ);

    return ψ;
}

/* EXAMPLES */

def channel(ψ:(𝔹^3)^3) { // flip both one qubit and its phase in a 3x3 structure
    ψ[0][1] := Z(ψ[0][1]); 
    ψ[0][1] := X(ψ[0][1]); 
    return ψ; 
}

def main() {
    // Example 1: basis state
    ψ := 1:𝔹; 
    φ := shor_code(ψ, channel); 
    // verifies that φ = 1
    forget(φ=1);

    // Example 2: superposition
    ψ := H(1:𝔹); 
    φ := shor_code(ψ, channel); 
    // verifies that φ = H(|1>)
    return φ;
}// Simon's algorithm 

def main() {
  return Simon();
}

def Simon(){
  // Initializing Qubits for Inputs - a,b,c and Oracle - d,e,f
  a:=0:𝔹;
  b:=0:𝔹;
  c:=0:𝔹;
  d:=0:𝔹;
  e:=0:𝔹;
  f:=0:𝔹;

  // Applying Hadamard to Inputs
  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Encoding 011 secret key in the Oracle

  if b{
    d := X(d);
  }

  if b{
    e := X(e);
  }

  if c{
    d := X(d);
  }

  if b{
    f := X(f);
  }

  if c{
    e := X(e);
  }

  if c{
    f := X(f);
  }

  // Applying Hadamard to Inputs

  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Measure the d,e,f qubits for variable consumption

  md:=measure(d);
  me:=measure(e);
  mf:=measure(f);

  return (a,b,c,md,me,mf);
}// Simon's algorithm 

def main() {
  return Simon();
}

def Simon(){
  // Initializing Qubits for Inputs - a,b,c and Oracle - d,e,f
  a:=0:𝔹;
  b:=0:𝔹;
  c:=0:𝔹;
  d:=0:𝔹;
  e:=0:𝔹;
  f:=0:𝔹;

  // Applying Hadamard to Inputs
  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Encoding 011 secret key in the Oracle

  if b{
    d := X(d);
  }

  if b{
    e := X(e);
  }

  if c{
    d := X(d);
  }

  if b{
    f := X(f);
  }

  if c{
    e := X(e);
  }

  if c{
    f := X(f);
  }

  // Applying Hadamard to Inputs

  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Measure the d,e,f qubits for variable consumption

  md:=measure(d);
  me:=measure(e);
  mf:=measure(f);

  return (a,b,c,md,me,mf);
}def main() {
  return Hadamard();
}

def Hadamard() {
  x:=0:𝔹;
  return H(x);
}

def PauliZ() {
  z:=1:𝔹;
  return Z(z);
}

def PauliY() {
  y:=1:𝔹;
  return Y(y);
}

def PauliX() {
  x:=0:𝔹;
  return X(x);
}def main(){
    return SuperDenseCoding();
}

def SuperDenseCoding(){
    a:=0:𝔹;
    b:=0:𝔹;

    // Bell State Preparation
    a:=H(a);
    if a{
        b:= X(b);
    }
    // Alice's Operation - 11 is sent 
    a:=Z(a);
    a:=X(a);
    // Bob's Operation 
    if a{
        b:= X(b);
    }
    a:=H(a);
    return (a,b);
}def main() {
  return SuperDenseCoding();
}

def SuperDenseCoding(){
  a:=0:𝔹;
  b:=0:𝔹;
  
  // Bell State Preparation
  a:=H(a);
  if a{
    b := X(b);
  }

  // Alice's Operation - 11 is sent
  a:=Z(a);
  a:=X(a);

  // Bob's Operation
  if a{
    b := X(b);
  }

  a:=H(a);

  return(a,b);
}def main() {
    return UniformSuperposition[1]();
}

def UniformSuperposition[n:!ℕ]():𝔹^n{
    qubits := vector(n,0:𝔹); //vector of length n filled with zeros


    for i in [0..n){
        qubits[i]:= H(qubits[i]);
    }
    return qubits;


}


// Superposition generation
// - Generates the (normalized) superposition |0⟩ + ... + |N-1⟩ on k qubits  
//  
// - Requires N < 2^k

def superposition[k:!ℕ](N:!ℕ, qs:𝔹^k)mfree:𝔹^k{ 
    // generates the (normalized) superposition |0⟩ + ... + |N-1⟩ on k qubits

    assert(N <= 2^k); 
    // ensures that the biggest state |N-1⟩ requires less than k qubits to be written
   
    n := floor(log(N)/log(2)) coerce !ℕ;
    r := N - 2^n coerce !ℕ;
    // decomposition N = 2^n + r

    // rotate first qubit
    (head,)~tail := qs; 
    θ := 2*asin(sqrt(r)/sqrt(N));
    // sin(θ/2) = sqrt(r/N), cos(θ/2) = sqrt((N-r)/N) = sqrt(2^n/N)
	
    head := rotY(θ, head); 
    // |0⟩ ↦ cos(θ/2)|0⟩ + sin(θ/2)|1⟩ = sqrt(2^n/N) |0⟩ + sqrt(r/N)|1⟩

    // state : 
    // (sqrt(2^n)/sqrt(N))|0⟩⊗(|0⟩⊗ ⋯ ⊗|0⟩) + (sqrt(r)/sqrt(N))|1⟩⊗(|0⟩⊗ ⋯ ⊗|0⟩)

    // conditionally on first qubit either prepare 
    // the uniform distribution on n qubits or 
    // (recursively) the remainder |0⟩ + ... + |r-1⟩
    if head {
        tail := superposition(r, tail); // (|0⟩ + ... + |r-1⟩)/sqrt(r)
    }
    else {
        for i in [0..n) { tail[i] := H(tail[i]); } // ∑ᵥ|v⟩/sqrt(2^n)
    }

    // tail = (x₁, ..., xₙ, xₙ₊₁, ..., xₖ) and 
    // head (= x₀) is the MSB of (x₁, ..., xₙ, x₀)
    for i in [0..n div 2) { (tail[i], tail[n-1-i]) := (tail[n-1-i], tail[i]); } 
    // tail = (xₙ, ..., x₁, xₙ₊₁, ..., xₖ)
    
    qs:=(head,)~tail;                                                           
    // qs = (x₀, xₙ, ..., x₁, xₙ₊₁, ..., xₖ)
    
    for i in [0..(n+1) div 2) { (qs[i], qs[n-i]) := (qs[n-i], qs[i]); }         
    // qs = (x₁, ..., xₙ, x₀, xₙ₊₁, ..., xₖ)

    // state :   
    // (sqrt(2^n)/sqrt(N))|0⟩⊗(∑ᵥ|v⟩/sqrt(2^n)) + 
    // (sqrt(r)/sqrt(N))|1⟩⊗((|0⟩ + ... + |r-1⟩)/sqrt(r)
    // = (1/sqrt(N))(|0⟩ + ... + |N-1⟩)

    return qs;
}

/* TEST */

def test_superposition() { 
    k := 5;
    qs := vector(k, 0:𝔹);
    qs := superposition(19, qs);
    measure(qs);
}

/* EXAMPLE CALL */

def main() {
    N := 19;
    // generates the normalized superposition |0⟩ + ... + |18⟩ on 5 qubits
    qs := superposition(N,  vector(5, 0:𝔹)) as uint[5];

    // measures 0 <= n < 19 
    n := measure(qs); 
    assert(n < N);
    return(n);
}def solve[n:!ℕ](bits:!𝔹^n){
  // prepare superposition between 0 and 1
  x:=H(0:𝔹);
  // prepare superposition between bits and 0
  qs := if x then bits else (0:int[n]) as 𝔹^n;
  // uncompute x
  forget(x=qs[0]); // valid because `bits[0]==1`
  return qs;
}

// EXAMPLE CALL

def main(){
  // example usage for bits=1, n=2
  x := 1:!int[2];
  y := x as !𝔹^2;
  return solve(y);
}// def solve[n:!ℕ](bits:!𝔹^n){
//   x:=H(0:𝔹);
//   qs := if x then bits else (0:int[n]) as 𝔹^n;
//   forget(x=qs[0]); 
//   return qs;
// }


// def main(){
//   x := 1:!int[2];
//   y := x as !𝔹^2;
//   return solve(y);
// }




// 定义 solve 函数，输入参数是一个名为 bits 的布尔数组，长度为 n
def solve[n:!ℕ](bits:!𝔹^n) {
  // 使用 H 表示哈达玛德门操作生成一个初始量子态 x
  x := H(0:𝔹);
  // 根据初始量子态和输入参数 bits，构造一个新的量子态 qs
  // 如果初始量子态为 1，则 qs 等于 bits；否则，qs 是一个全0的 𝔹^n 布尔数组
  qs := if x then bits else (0:int[n]) as 𝔹^n;
  // 忘记量子态 x 和 qs[0] 之间的等式
  forget(x=qs[0]);
  // 返回构造好的量子态 qs
  return qs;
}

// 定义 main 函数
def main() {
  // 定义一个长度为 2 的整型数组 x，并赋值为 [1, 0]
  x := 1:!int[2];
  // 将 x 强制转换为 𝔹^2 类型的布尔数组 y
  y := x as !𝔹^2;
  // 调用 solve 函数，将 y 作为参数传入，并返回其返回值
  return solve(y);
}
def main() {
  return Teleportation();
}

def Teleportation(){

  // Initialize Qubits - 'a' qubit is to be teleported by Alice to Bob
  a:=0:𝔹;
  b:=0:𝔹;
  c:=0:𝔹;

  // Alice's Operations

  // Creating the Bell State
  b:=H(b);

  if b{
    c := X(c);
  }

  // Alice applies CX and H to 'a' qubit

  if a{
    b := X(b);
  }

  a:=H(a);

  // Alice measures her qubits 'a' and 'b'

  ma1:=measure(a);
  ma2:=measure(b);
  print(ma1);
  print(ma2);

  // Bob's measurement

  //c:=X(c);
  //c:=Z(c);

  return (c);
}def QFT[n:!N] (qs:B^n) mfree:B^n {
    for i in [0..n) {
        qs[i] := H(qs[i]);

        for j in [i+1..n) {
            qs[j] := U1(π/2^(j - i), qs[j]);
        }
    }

    return swap_all(qs);
}

def swap_all[n:!N] (qs:B^n) mfree:B^n {
    for i in [0..n div 2) {
      (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
    }

    return qs;
}

def U1 (r:!ℝ, q:B) mfree {
    if q { phase(r) }
    return q;
}


def solve[n:!ℕ](bits:!𝔹^n){
  // prepare superposition between 0 and 1
  x:=H(0:𝔹);
  // prepare superposition between bits and 0
  qs := if x then bits else (0:int[n]) as 𝔹^n;
  // uncompute x
  forget(x=qs[0]); // valid because `bits[0]==1`
  return qs;
}

// EXAMPLE CALL

// def main(){
//   // example usage for bits=1, n=2
//   x := 1:!int[2];
//   y := x as !𝔹^2;
//   return solve(y);
// }

def main(){
    // 定义 x 为一个二进制位长度为2的整数，初始值为1
    x := 1:!int[2];
    // 使用 as 运算符将 x 转换为一个长度为2的布尔值数组，赋值给变量 y
    y := x as !𝔹^2;
    // 调用 solve() 函数，并将 y 作为参数传递给该函数，并返回其结果
    return solve(y);
}
// def main() {
//     // 定义整数变量 x 和 y，并赋初值为 3 和 5
//     x := 3;
//     y := 5;

//     // 计算 x 和 y 的和，并将结果赋值给变量 z
//     z := x + y;

//     // 输出变量 z 的值
//     print(z);
// }


def main() {
    x := 0 ;
    x : B ;
    print(measure(x));
}
// 定义 cost 和 mixer 函数
def cost(qubits : Qubit[], iter : Int) : Double {
    // 定义无向图的邻接矩阵，表示 4 条边 6 个点的无向图
    adj_matrix := [
        [false, true, false, false, true, true],
        [true, false, true, false, false, true],
        [false, true, false, true, false, true],
        [false, false, true, false, true, true],
        [true, false, false, true, false, true],
        [true, true, true, true, true, false]
    ];
    // 计算最大切割的成本
    cut := 0.0;
    for i in 0 .. Length(qubits) - 1 {
        for j in i + 1 .. Length(qubits) - 1 {
            if adj_matrix[i][j] {
                weight := 1.0 - Measure([qubits[i], qubits[j]]);
                cut += weight;
            }
        }
    }
    return cut;
}

// function mixer(qubits : Qubit[], gamma : Double) : Unit {
//     // 应用 Hadamard 门
//     ApplyToEach(H, qubits);
//     // 应用 Ising 模型混合项
//     for i in 0 .. Length(qubits) - 2 {
//         let theta = gamma * (Double(i) + 1.0) / Double(Length(qubits) - 1);
//         for j in i + 1 .. Length(qubits) - 1 {
//             let w = if j == i + 1 then 1.0 else 2.0;
//             CPhase(theta * w, (qubits[i], qubits[j]));
//         }
//     }
//     // 应用 Hadamard 门
//     ApplyToEach(H, qubits);
// }

// // 定义 QAOA 算法函数
// operation qaoa(p : Int, cost_func : ((Qubit[], Int) => Double), mixer_func : ((Qubit[], Double) => Unit)) : Double {
//     // 创建量子比特数组和初始超位置态
//     using (qubits = Qubit[p]) {
//         ApplyToEach(H, qubits);
//         // 应用 QAOA 迭代
//         for i in 1 .. p {
//             let gamma = 2.0 * Pi() * Double(i) / Double(p);
//             cost_func(qubits, i);
//             mixer_func(qubits, gamma);
//         }
//         // 测量结果
//         let result = MeasureAllZ(qubits);
//         ResetAll(qubits);
//         return result;
//     }
// }

// // 测试 QAOA 算法
// function main() : Unit {
//     let p = 2;
//     let result = qaoa(p, cost, mixer);
//     Message($"QAOA result: {result}");
// }
// 创建一个二维数组，表示无向图中的边
edges := [
    [0, 1],
    [0, 2],
    [0, 3],
    [1, 2],
    [1, 3],
    [2, 3]
];

// 输出数组中的元素
for (i in 0 .. Length(edges) - 1) {
    Message($"{edges[i]} ");
}




// // 输出无向图的表示
// for (i in 0 .. 3) {
//     for (j in i + 1 .. 3) {
//         if ([i, j] in edges or [j, i] in edges) {
//             Message($"({i}, {j})");
//         } else {
//             Message($"({i}, {j}) -- 0");
//         }
//     }
// }
def main() {
  return UniformSuperposition[1]();
}

def UniformSuperposition[n:!ℕ]():𝔹^n{
  qubits := vector(n,0:𝔹); // vector of length n filled with zeros
  for i in [0..n){
    qubits[i] := H(qubits[i]);
  }
  return qubits;
}