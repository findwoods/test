def main(){
    b:=1:ğ”¹;
    b:=H(b);

    c:=1:ğ”¹;
    if b{
        c:= X(c);
    }

    return (b,c);
}def main() {
  return BellState();
}

def BellState(){
  b:=1:ğ”¹;
  b:=H(b);
   
  c:=1:ğ”¹;
  if b{
    c := X(c);
  }

  return (b,c);

}// Bernstein-Vazirani algorithm
// - Returns s where f(x) = sÂ·x mod 2
//

def bernstein_vazirani[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!uint[n]{
  cand := 0:uint[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // âˆ‘áµ¥|vâŸ©

  if f(cand) {
    phase(Ï€);
  }

  // state ignoring normalization:
  //   âˆ‘áµ¥(-1)^f(v)  |vâŸ©
  // = âˆ‘áµ¥(-1)^(sÂ·v) |vâŸ©
  // = (|0âŸ©+(-1)^(sâ‚)|1âŸ©) âŠ— â‹¯ âŠ— (|0âŸ©+(-1)^(sâ‚™)|1âŸ©)

  for k in [0..n) { cand[k] := H(cand[k]); }

  s := measure(cand);
  return s;
}

/* TEST */

def f[n:!â„•](s:!uint[n])(x:uint[n])lifted:ğ”¹{
  y := scal(s, x)%2;
  return y==1;
}

def scal[n:!â„•](const x:uint[n], const y:uint[n])qfree:uint[n] { 
  // computes the scalar product xÂ·y
  count := 0:uint[n];
  for k in [0..n) { 
    count+=x[k] && y[k];
  }
  return count;
}

def main() {
  // test  with all secret strings on 3 bits
  for i in [0..8) {
	  s := i coerce !uint[3];
	  sâ‚€ := bernstein_vazirani(f(s));
	  assert(s==sâ‚€);
  }

  // test with secret string s = 01
  s := 1 coerce !uint[2];
  sâ‚€ := bernstein_vazirani(f(s));
  return sâ‚€;

}
// Bernstein-Vazirani algorithm
// - Returns s where f(x) = sÂ·x mod 2
//

def bernstein_vazirani[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!uint[n]{
  cand := 0:uint[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // âˆ‘áµ¥|vâŸ©

  if f(cand) {
    phase(Ï€);
  }

  // state ignoring normalization:
  //   âˆ‘áµ¥(-1)^f(v)  |vâŸ©
  // = âˆ‘áµ¥(-1)^(sÂ·v) |vâŸ©
  // = (|0âŸ©+(-1)^(sâ‚)|1âŸ©) âŠ— â‹¯ âŠ— (|0âŸ©+(-1)^(sâ‚™)|1âŸ©)

  for k in [0..n) { cand[k] := H(cand[k]); }

  s := measure(cand);
  return s;
}

/* TEST */

def f[n:!â„•](s:!uint[n])(x:uint[n])lifted:ğ”¹{
  y := scal(s, x)%2;
  return y==1;
}

def scal[n:!â„•](const x:uint[n], const y:uint[n])qfree:uint[n] { 
  // computes the scalar product xÂ·y
  count := 0:uint[n];
  for k in [0..n) { 
    count+=x[k] && y[k];
  }
  return count;
}

def main() {
  // test  with all secret strings on 3 bits
  for i in [0..8) {
	  s := i coerce !uint[3];
	  sâ‚€ := bernstein_vazirani(f(s));
	  assert(s==sâ‚€);
  }

  // test with secret string s = 01
  s := 1 coerce !uint[2];
  sâ‚€ := bernstein_vazirani(f(s));
  return sâ‚€;

}



// Bit-Flip code (Quantum error correction)
// - Returns the qubit Ïˆ where Ïˆ is encoded to a 3-qubit state and then  
// - passed through a noisy channel potentially flipping one of the qubits


def encode(Ïˆ:ğ”¹) mfree { // encode a single qubit Ïˆ into a 3-qubit state
    Ïˆ := (dup(Ïˆ), dup(Ïˆ), Ïˆ);
    
    return Ïˆ;
}

def correct(Ïˆ:ğ”¹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    p1 := measure(Ïˆ[0] âŠ• Ïˆ[1]);
    p2 := measure(Ïˆ[0] âŠ• Ïˆ[2]);

    // apply the appropriate correction
    if (p1 && p2) {
        Ïˆ[0] := X(Ïˆ[0]);
    } else if (p1) {
        Ïˆ[1] := X(Ïˆ[1]);
    } else if (p2) {
        Ïˆ[2] := X(Ïˆ[2]);
    }

    return Ïˆ;
}

def bit_flip_code(Ïˆ: ğ”¹, channel: ğ”¹^3 !â†’ ğ”¹^3) { // simulate the bit-flip code error-correcting process
    Ïˆ := encode(Ïˆ);
    Ïˆ := channel(Ïˆ);
    Ïˆ := correct(Ïˆ);
    Ïˆ := reverse(encode)(Ïˆ);

    return Ïˆ;
}

/* EXAMPLES */

def channel(Ïˆ:ğ”¹^3) { // flip the first qubit of a 3-qubit state
    Ïˆ[0] := X(Ïˆ[0]);
    return Ïˆ;
}

def main() {
    // Example 1: basis state
    Ïˆ := 1:ğ”¹; 
    Ï† := bit_flip_code(Ïˆ, channel); 
    // verifies that Ï† = 1
    forget(Ï† = 1);

    // Example 2: superposition
    Ïˆ := H(1:ğ”¹); 
    Ï† := bit_flip_code(Ïˆ, channel); 
    // verifies that Ï† = H(|1>)
    return Ï†;
}


def main(){
    return CCX(1:ğ”¹,1:ğ”¹,1:ğ”¹);
}

def CCX(const x:ğ”¹,const y:ğ”¹,z:ğ”¹):ğ”¹
{
    if x && y{
        z:=X(z);
    }

    return (z);
}def main(){
    return CX(1:ğ”¹, 0:ğ”¹);
}


def CX(const x:ğ”¹, y:ğ”¹):ğ”¹{
    if x{
        y:=X(y);
    }
    return y;
}def main(){
    return CSWAP(1:ğ”¹,0:ğ”¹,1:ğ”¹);
}

def CSWAP(x:ğ”¹,y:ğ”¹,z:ğ”¹){
    if x{
        a:=z;
        z:=y;
        y:=a;
    }

    return (x,y,z);
}def main() {
    return CZ(1:ğ”¹,1:ğ”¹);

}

def CZ(const x:ğ”¹,y:ğ”¹):ğ”¹{
    if x{
        y:=Z(y);
    }

    return y;
}def main() {
  return DecomposedCX();
}

def DecomposedCX(){
  b:=1:ğ”¹;
  b:=H(b);

  a:=1:ğ”¹;
  if a{
    b := Z(b);
  }

  b:=H(b);

  return b;
}def main(){
    return DecomposedCX();
}

def DecomposedCX(){
    b:=1:ğ”¹;
    b:=H(b);
    a:=1:ğ”¹;
    if a{
        b:=Z(b);

    }
    b:=H(b);
    return b;
}// Deutsch-Jozsa algorithm 
// - Returns : | 0 if f is balanced (#{x, f(x)=0} = #{x, f(x)=1})
//             | 1 if f is constant (âˆ€x f(x)=0 or âˆ€x f(x)=1)


def deutsch_jozsa[n:!â„•](f: const int[n] !â†’ lifted ğ”¹):!ğ”¹{
  cand := 0:int[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // âˆ‘áµ¥|vâŸ©

  if f(cand) {
	  phase(Ï€);
  }

  // state ignoring normalization:
  // âˆ‘áµ¥(-1)^f(v)|vâŸ©

  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  //   âˆ‘áµ¥(-1)^f(v) âˆ‘áµ¤ (-1)^(uÂ·v)|uâŸ©  

  result := measure(cand);
  // probability to measure 0 is:
  // - 1 if f constant (constructive interference) 
  // - 0 if f balanced (destructive interference)
  return result==0;
}

/* TEST */

def test_balanced() {
  def balanced(x:int[2])lifted:ğ”¹{
    if (x[0]==1) { 
      return 1:ğ”¹;
    }
    else {
      return 0:ğ”¹;
    }
  } // implements a balanced function (outputs half 0 and half 1)
  x := deutsch_jozsa(balanced);
  assert(x == 0); 
  return x;
}

def test_constant() {
  def constant(x:int[2])lifted:ğ”¹{
    return 1:ğ”¹;
  } // implements a constant function (outputs only 1)
  x := deutsch_jozsa(constant);
  assert(x == 1);
  return x;
}

def main() {
  print(test_balanced()); // DJ on balanced function should output 0
  print(test_constant()); // DJ on constant function should output 1
  return;
}// Deutsch-Jozsa algorithm 
// - Returns : | 0 if f is balanced (#{x, f(x)=0} = #{x, f(x)=1})
//             | 1 if f is constant (âˆ€x f(x)=0 or âˆ€x f(x)=1)


def deutsch_jozsa[n:!â„•](f: const int[n] !â†’ lifted ğ”¹):!ğ”¹{
  cand := 0:int[n];
  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  // âˆ‘áµ¥|vâŸ©

  if f(cand) {
	  phase(Ï€);
  }

  // state ignoring normalization:
  // âˆ‘áµ¥(-1)^f(v)|vâŸ©

  for k in [0..n) { cand[k] := H(cand[k]); }

  // state ignoring normalization:
  //   âˆ‘áµ¥(-1)^f(v) âˆ‘áµ¤ (-1)^(uÂ·v)|uâŸ©  

  result := measure(cand);
  // probability to measure 0 is:
  // - 1 if f constant (constructive interference) 
  // - 0 if f balanced (destructive interference)
  return result==0;
}

/* TEST */

def test_balanced() {
  def balanced(x:int[2])lifted:ğ”¹{
    if (x[0]==1) { 
      return 1:ğ”¹;
    }
    else {
      return 0:ğ”¹;
    }
  } // implements a balanced function (outputs half 0 and half 1)
  x := deutsch_jozsa(balanced);
  assert(x == 0); 
  return x;
}

def test_constant() {
  def constant(x:int[2])lifted:ğ”¹{
    return 1:ğ”¹;
  } // implements a constant function (outputs only 1)
  x := deutsch_jozsa(constant);
  assert(x == 1);
  return x;
}

def main() {
  print(test_balanced()); // DJ on balanced function should output 0
  print(test_constant()); // DJ on constant function should output 1
  return;
}
def main() {
  x:=0:ğ”¹;
  return H(x);
}def geometric():!â„•{
    count := 0;
    ok := true;
    while ok{
        count += 1;
        ok = measure(H(false));
    }
    return count;
}

def main() {
    return geometric();
}def main() {
  return geometric();
}

def geometric():!â„•{
    count := 0;
    ok := true;
    while ok{
        count += 1;
        ok = measure(H(false));
    }
    return count;
}def main(){
    return GHZ();
}

def GHZ(){
    a:=0:ğ”¹;
    b:=0:ğ”¹;
    c:=0:ğ”¹;
    a:=H(a);
    if a{
        b:= X(b);
    }
    if b{
        c:= X(c);

    }
    return (a,b,c);
}def main() {
  return GHZ();
}

def GHZ(){
  a:=0:ğ”¹;
  b:=0:ğ”¹;
  c:=0:ğ”¹;

  a:=H(a);

  if a{
    b := X(b);
  }

  if b{
    c := X(c);
  }

  return (a,b,c);

}// Grover's algorithm for an unknown number of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/pdf/1709.01236.pdf


// Random number generators

def uniformInt(range:!â„•){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !â„•;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}



// Grover Diffusion Operator

def groverDiffusion[n:!â„•](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(Ï€); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}

def grover_unknown[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!â„•{
	m := 1:!â„š;
	l := 6/5;

	while (m <= 2^(n/2)) {
		nIterations := uniformInt(floor(m) coerce !â„•) + 1;
		
		cand := 0:uint[n];
    	for k in [0..n) {cand[k] := H(cand[k]);}
		
		for k in [0..nIterations){
			if f(cand){
				phase(Ï€);
			}
		cand:=groverDiffusion(cand);
		}

		x := measure(cand);

		if f(x) {return x as !â„•;}
		else {m=l*m;}
	}

	return 0;
}

/* EXAMPLE CALL */

def main(){
	f := Î»(x:uint[5])lifted:ğ”¹{ return x==1 || x==2 || x==5 || x==8; }; 
	// creates an oracle which outputs one only when x is in {1,2,5,8}
	
	x := grover_unknown(f); 
	
	assert(x==1 || x==2 || x==5 || x==8); 
	// verifies that grover_unknown finds one of the right solutions

	return x;
}



/* TEST */ 

// This function defines tests for Grover with respectively 1, 2, 3 and 4 solutions
def test_grover_unknown() {
	n := 5;
	def f1(x:uint[n])lifted:ğ”¹{
    	return x==1;
	}
	def f2(x:uint[n])lifted:ğ”¹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:ğ”¹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:ğ”¹{
    	return x==7 || x==8 || x==9 || x==10;
	}
	 // creates oracles with respectively 1, 2, 3 and 4 solutions
	x := grover_unknown(f1);
	y := grover_unknown(f2);
	z := grover_unknown(f3);
	w := grover_unknown(f4);
	// verifies that grover_unknown finds one of the right solutions
	assert(x==1);
	assert(y==2 || y==3);
	assert(z==4 || z==5 || z==6);
	assert(w==7 || w==8 || w==9 || w==10);
}
// Grover's algorithm for a known number (M) of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/ftp/arxiv/papers/0705/0705.4171.pdf

// Grover Diffusion Operator

def groverDiffusion[n:!â„•](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(Ï€); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}
// Random number generators

def uniformInt(range:!â„•){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !â„•;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}


def grover_multiple[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹, M:!â„•):!â„•{
	nIterations:= round((Ï€/4) * sqrt(2^n/M));
	cand:=0:uint[n];
    for k in [0..n) { cand[k] := H(cand[k]); }
	
	for k in [0..nIterations){
		if f(cand){
			phase(Ï€);
		}
		cand:=groverDiffusion(cand);
	}
	return measure(cand) as !â„•;
}

/* EXAMPLE CALL */

def main(){
	f := Î»(x:uint[6])lifted:ğ”¹{ return x==4 || x==5 || x==6; }; 
	// creates an oracle which outputs one only when x is in {4,5,6}
	
	x := grover_multiple(f, 3); 
	
	assert(x==4 || x==5 || x==6); 
	// verifies that grover_multiple finds one of the right solutions

	return x;
}

/* TEST */

// This function defines tests for Grover with respectively 2, 3 and 4 solutions
def test_grover_multiple() {
	n := 6;
	def f2(x:uint[n])lifted:ğ”¹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:ğ”¹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:ğ”¹{
    	return x==7 || x==8 || x==9 || x==10;
	} // creates oracles with respectively 2, 3 and 4 solutions
	x := grover_multiple(f2, 2);
	y := grover_multiple(f3, 3);
	z := grover_multiple(f4, 4);
	// verifies that grover_multiple finds one of the right solutions
	assert(x==2 || x==3);
	assert(y==4 || y==5 || y==6);
	assert(z==7 || z==8 || z==9 || z==10);
}
def groverDiff[n:!N](cand:uint[n]){
  for k in [0..n) {
        cand[k]:= H(cand[k]);
        cand[k]:= X(cand[k]);

    }
   if (cand=3){phase(Ï€);}
   for k in [0..n) {
        cand[k]:= X(cand[k]);
        cand[k]:= H(cand[k]);

   }
   return cand;
}
def grover[n:!N](f:const uint[n]!->qfree B){
    nInteration := 1;
    cand := 0:uint[n];
    for k in [0..n) {
        cand[k]:= H(cand[k]);
    }
   // dump();
    for k in [0..nInteration){
        if (f(cand)){phase(Ï€);}
        cand := groverDiff[n](cand);
    }
    dump();
    return measure(cand);
}
//Oracle
def f[n:!N](const cand:uint[n])qfree:B {
    return cand=2 || cand=3;
}
def main(){
    n := 3:!N;
    //dump();
    m := grover[n](f[n]);
   // dump();
}// Grover Diffusion Operator

def groverDiffusion[n:!â„•](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(Ï€); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}
// Grover's algorithm for a known number (M) of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/ftp/arxiv/papers/0705/0705.4171.pdf


import helpers.groverDiffusion;

def grover_multiple[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹, M:!â„•):!â„•{
	nIterations:= round((Ï€/4) * sqrt(2^n/M));
	cand:=0:uint[n];
    for k in [0..n) { cand[k] := H(cand[k]); }
	
	for k in [0..nIterations){
		if f(cand){
			phase(Ï€);
		}
		cand:=groverDiffusion(cand);
	}
	return measure(cand) as !â„•;
}

/* EXAMPLE CALL */

def main(){
	f := Î»(x:uint[6])lifted:ğ”¹{ return x==4 || x==5 || x==6; }; 
	// creates an oracle which outputs one only when x is in {4,5,6}
	
	x := grover_multiple(f, 3); 
	
	assert(x==4 || x==5 || x==6); 
	// verifies that grover_multiple finds one of the right solutions

	return x;
}

/* TEST */

// This function defines tests for Grover with respectively 2, 3 and 4 solutions
def test_grover_multiple() {
	n := 6;
	def f2(x:uint[n])lifted:ğ”¹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:ğ”¹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:ğ”¹{
    	return x==7 || x==8 || x==9 || x==10;
	} // creates oracles with respectively 2, 3 and 4 solutions
	x := grover_multiple(f2, 2);
	y := grover_multiple(f3, 3);
	z := grover_multiple(f4, 4);
	// verifies that grover_multiple finds one of the right solutions
	assert(x==2 || x==3);
	assert(y==4 || y==5 || y==6);
	assert(z==7 || z==8 || z==9 || z==10);
}



// Grover's algorithm for a single solution
// - Returns the only x for which f(x) = 1
//
// - More detailed description: https://www.scottaaronson.com/qclec/22.pdf

import helpers.groverDiffusion;

def grover[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!â„•{ 
	nIterations:= round(Ï€ / 4 * sqrt(2^n));
	cand:=0:uint[n];
    for k in [0..n) {cand[k] := H(cand[k]);} 
	
	for k in [0..nIterations){
		if f(cand){
			phase(Ï€);
		}		
		// state ignoring normalization:   
    	// âˆ‘(vâ‰ w)|vâŸ© - |w*âŸ©
		cand:=groverDiffusion(cand);  
    	// âˆ‘(vâ‰ w)Î³â‚‹|vâŸ© + Î³â‚Š|w*âŸ©
	}
	return measure(cand) as !â„•;
}

/* EXAMPLE CALL */

def main() {
	f := Î»(x:uint[5])lifted:ğ”¹{return x==3;}; // creates an oracle which outputs one only when x=3
	x := grover(f); 
	assert(x==3); // verifies that grover finds the right solution

	return x;
}

/* TEST */ 

// This function defines a test for Grover
def test_grover() {
	def f(x:uint[3])lifted:ğ”¹{
    	return x==7;
	} // creates an oracle which outputs one only when x=3
	x := grover(f);
	// verifies that grover finds the right solution
	assert(x==7);

	return x;
}


// Grover's algorithm for a single solution
// - Returns the only x for which f(x) = 1
//
// - More detailed description: https://www.scottaaronson.com/qclec/22.pdf


def grover[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!â„•{ 
	nIterations:= round(Ï€ / 4 * sqrt(2^n));
	cand:=0:uint[n];
    for k in [0..n) {cand[k] := H(cand[k]);} 
	
	for k in [0..nIterations){
		if f(cand){
			phase(Ï€);
		}		
		// state ignoring normalization:   
    	// âˆ‘(vâ‰ w)|vâŸ© - |w*âŸ©
		cand:=groverDiffusion(cand);  
    	// âˆ‘(vâ‰ w)Î³â‚‹|vâŸ© + Î³â‚Š|w*âŸ©
	}
	return measure(cand) as !â„•;
}

/* EXAMPLE CALL */

def main() {
	f := Î»(x:uint[5])lifted:ğ”¹{return x==3;}; // creates an oracle which outputs one only when x=3
	x := grover(f); 
	assert(x==3); // verifies that grover finds the right solution

	return x;
}

// Grover Diffusion Operator

def groverDiffusion[n:!â„•](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(Ï€); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}


/* TEST */

// Random number generators

def uniformInt(range:!â„•){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !â„•;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}



// This function defines a test for Grover
def test_grover() {
	def f(x:uint[3])lifted:ğ”¹{
    	return x==7;
	} // creates an oracle which outputs one only when x=3
	x := grover(f);
	// verifies that grover finds the right solution
	assert(x==7);

	return x;
}// Grover's algorithm for an unknown number of solutions
// - Returns one of the x for which f(x) = 1
//
// - More detailed description: https://arxiv.org/pdf/1709.01236.pdf

import helpers.groverDiffusion;
import helpers.rand;

def grover_unknown[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!â„•{
	m := 1:!â„š;
	l := 6/5;

	while (m <= 2^(n/2)) {
		nIterations := uniformInt(floor(m) coerce !â„•) + 1;
		
		cand := 0:uint[n];
    	for k in [0..n) {cand[k] := H(cand[k]);}
		
		for k in [0..nIterations){
			if f(cand){
				phase(Ï€);
			}
		cand:=groverDiffusion(cand);
		}

		x := measure(cand);

		if f(x) {return x as !â„•;}
		else {m=l*m;}
	}

	return 0;
}

/* EXAMPLE CALL */

def main(){
	f := Î»(x:uint[5])lifted:ğ”¹{ return x==1 || x==2 || x==5 || x==8; }; 
	// creates an oracle which outputs one only when x is in {1,2,5,8}
	
	x := grover_unknown(f); 
	
	assert(x==1 || x==2 || x==5 || x==8); 
	// verifies that grover_unknown finds one of the right solutions

	return x;
}



/* TEST */ 

// This function defines tests for Grover with respectively 1, 2, 3 and 4 solutions
def test_grover_unknown() {
	n := 5;
	def f1(x:uint[n])lifted:ğ”¹{
    	return x==1;
	}
	def f2(x:uint[n])lifted:ğ”¹{
    	return x==2 || x==3;
	}
	def f3(x:uint[n])lifted:ğ”¹{
    	return x==4 || x==5 || x==6;
	}
	def f4(x:uint[n])lifted:ğ”¹{
    	return x==7 || x==8 || x==9 || x==10;
	}
	 // creates oracles with respectively 1, 2, 3 and 4 solutions
	x := grover_unknown(f1);
	y := grover_unknown(f2);
	z := grover_unknown(f3);
	w := grover_unknown(f4);
	// verifies that grover_unknown finds one of the right solutions
	assert(x==1);
	assert(y==2 || y==3);
	assert(z==4 || z==5 || z==6);
	assert(w==7 || w==8 || w==9 || w==10);
}



def main(){
    return Hadamard();
}

def Hadamard(){
    x:=0:ğ”¹;
    return H(x);
}def main(){
    return HalfAdder();
}

def HalfAdder(){
    //Define 4 Qubits - a & b inputs, s & c are sum and carry -
    // outputs

    a:=1:ğ”¹;
    b:=1:ğ”¹;
    s:=0:ğ”¹;
    c:=0:ğ”¹;
    // XOR Gate Operation
    // CX operation on b and s qubit
    if b{
        s:=X(s);
    }
    // CX operation on a and s
    if a{
        s:= X(s);

    }
    // AND Gate Operation
    if a && b{
        c:= X(c);
    }

    return (s,c);

}def main() {
  return HalfAdder();
}

def HalfAdder(){
  // Define 4 Qubits - a & b inputs, s & c are sum and carry - outputs
  a:=1:ğ”¹;
  b:=1:ğ”¹;
  s:=0:ğ”¹;
  c:=0:ğ”¹;

  // XOR Gate Operation

  // CX operation on b and s qubit
  if b{
    s := X(s);
  }
  
  // CX operation on a and s
  if a{
    s := X(s);
  }

  // AND Gate Operation

  if a && b{
    c := X(c);
  }

  return (s,c);
}def CSWAP(x:ğ”¹, y:ğ”¹, z:ğ”¹) {
  if x{
    a:=z;
    z:=y;
    y:=a;
  }
  return (x,y,z);
}

def SWAP(x:ğ”¹, y:ğ”¹) {
  a:=y;
  y:=x;
  x:=a;
  return (x,y);
}

def CCX(const x:ğ”¹,const y:ğ”¹,z:ğ”¹):ğ”¹{
  if x && y{
    z := X(z);
  }
  return (z);
}

def CZ(const x:ğ”¹,y:ğ”¹):ğ”¹{
  if x{
    y := Z(y);
  }
  return y;
}

def CX(const x:ğ”¹,y:ğ”¹):ğ”¹{
  if x{
    y := X(y);
  }
  return y;
}def main() {
    return PauliX();
}

def PauliX(){
    x:=0:ğ”¹;
    return X(x);
}def main() {
    return PauliY();
}

def PauliY(){
    y:=1:ğ”¹;
    return Y(y);
}def main(){
    return PauliZ();
}

def PauliZ(){
    z:=1:ğ”¹;
    return Z(z);
}

// Phase Estimation algorithm

import qft;

def phaseEstimation[k:!â„•](
    U:int[k] !->mfree int[k],
    u:int[k], 
    precision:!â„•) {

    ancilla := 0:int[precision];
    for i in [0..precision) { ancilla[i] := H(ancilla[i]); }

    for i in [0..precision) { 
        if ancilla[i] {
            for l in [0..2^i) {
                u := U(u);
            }
        }
    }

    ancilla := reverse(QFT[precision])(ancilla);
    result := measure(ancilla);
    measure(u);
    return result;
}
// Phase-Flip code (Quantum error correction)
// - Returns the qubit Ïˆ where Ïˆ is encoded to a 3-qubit state and then  
// - passed through a noisy channel potentially flipping the phase of one of the qubits


def encode(Ïˆ:ğ”¹) mfree { // encode a single qubit Ïˆ into a 3-qubit state
    Ïˆ := (dup(Ïˆ), dup(Ïˆ), Ïˆ);
    
    return Ïˆ;}

def correct(Ïˆ:ğ”¹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    p1 := measure(Ïˆ[0] âŠ• Ïˆ[1]);
    p2 := measure(Ïˆ[0] âŠ• Ïˆ[2]);

    // apply the appropriate correction
    if (p1 && p2) {
        Ïˆ[0] := X(Ïˆ[0]);
    } else if (p1) {
        Ïˆ[1] := X(Ïˆ[1]);
    } else if (p2) {
        Ïˆ[2] := X(Ïˆ[2]);
    }

    return Ïˆ;
}

def phase_flip_code(Ïˆ: ğ”¹, channel: ğ”¹^3 !â†’ ğ”¹^3) { // simulate the phase-flip code error-correcting process
    Ïˆ := encode(Ïˆ);

    for k in [0..3) {Ïˆ[k] := H(Ïˆ[k]);}
    Ïˆ := channel(Ïˆ);
    for k in [0..3) {Ïˆ[k] := H(Ïˆ[k]);}

    Ïˆ := correct(Ïˆ);
    Ïˆ := reverse(encode)(Ïˆ);

    return Ïˆ;
}

/* EXAMPLES */

def channel(Ïˆ:ğ”¹^3) { // flip the phase of the second qubit of a 3-qubit state
    Ïˆ[1] := Z(Ïˆ[1]);
    return Ïˆ;
}

def main() {
    // Example 1: basis state
    Ïˆ := 0:ğ”¹; 
    Ï† := phase_flip_code(Ïˆ, channel); 
    // verifies that Ï† = 0
    forget(Ï† = 0);

    // Example 2: superposition
    Ïˆ := H(0:ğ”¹); 
    Ï† := phase_flip_code(Ïˆ, channel); 
    // verifies that Ï† = H(|0>)
    return Ï†;
}


// Quantum Fourier Transform


def QFT[n:!â„•](Ïˆ: int[n])mfree: int[n]{
	for k in [0..n div 2){
		(Ïˆ[k],Ïˆ[n-k-1]) := (Ïˆ[n-k-1],Ïˆ[k]);
	}
	for k in [0..n){
		Ïˆ[k] := H(Ïˆ[k]);
		for l in [k+1..n){
			if Ïˆ[l] && Ïˆ[k]{
				phase(2*Ï€ * 2^(k-l-1));
			}
		}
	}
	return Ïˆ;
}


def main(){
	Ïˆ := 2:int[2];
	return QFT(Ïˆ);
}
def QFT[n:!N] (qs:B^n) mfree:B^n {
    for i in [0..n) {
        qs[i] := H(qs[i]);

        for j in [i+1..n) {
            qs[j] := U1(Ï€/2^(j - i), qs[j]);
        }
    }

    return swap_all(qs);
}
def swap_all[n:!N] (qs:B^n) mfree:B^n {
    for i in [0..n div 2) {
      (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
    }

    return qs;
}
// Single-qubit rotation about the Z axis.
def U1 (r:!â„, q:B) mfree {
    if q { phase(r) }
    return q;
}



def QFT[n:!N] (qs:B^n) mfree:B^n { // é‡å­å‚…ç«‹å¶å˜æ¢å‡½æ•°
    for i in [0..n) {
        qs[i] := H(qs[i]); // å¯¹æ¯ä¸ªé‡å­æ¯”ç‰¹åº”ç”¨å“ˆå¯†é¡¿é—¨
        for j in [i+1..n) {
            qs[j] := U1(Ï€/2^(j - i), qs[j]); // åº”ç”¨CNOTé—¨
        }
    }
    
    return swap_all(qs); // äº¤æ¢æ‰€æœ‰é‡å­æ¯”ç‰¹
}

def swap_all[n:!N] (qs:B^n) mfree:B^n { // äº¤æ¢å‡½æ•°
    for i in [0..n div 2) { // äº¤æ¢ç›¸é‚»çš„é‡å­æ¯”ç‰¹
      (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
    }

    return qs;
}

// å•æ¯”ç‰¹ç»•zè½´æ—‹è½¬
def U1 (r:!â„, q:B) mfree { // å•ä¸ªé‡å­æ¯”ç‰¹ç»•Zè½´æ—‹è½¬
    if q { phase(r) }
    return q;
}








def QFT[n:!N] (qs:B^n) mfree:B^n { // Quantum Fourier Transform Function
    for i in [0..n) {
        qs[i] := H(qs[i]); // Apply Hadamard gate on each qubit

        for j in [i+1..n) {
            qs[j] := U1(Ï€/2^(j - i), qs[j]); // Apply Cnot gates
        }
    }
    
    return swap_all(qs); // Swap all qubits back in an order
}

def swap_all[n:!N] (qs:B^n) mfree:B^n { // Swap Function
    for i in [0..n div 2) { // Swap adjacent qubits 
      (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
    }

    return qs;
}

// Single-qubit rotation about the Z axis.
def U1 (r:!â„, q:B) mfree { // Rotation about the Z axis of a single qubit
    if q { phase(r) }
    return q;
}





// def QFT[n:!N] (qs:B^n) mfree:B^n {
//     for i in [0..n) {
//         qs[i] := H(qs[i]);

//         for j in [i+1..n) {
//             qs[j] := U1(Ï€/2^(j - i), qs[j]);
//         }
//     }

//     return swap_all(qs);
// }
// def swap_all[n:!N] (qs:B^n) mfree:B^n {
//     for i in [0..n div 2) {
//       (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
//     }

//     return qs;
// }
// def U1 (r:!â„, q:B) mfree {
//     if q { phase(r) }
//     return q;
// }




// å®šä¹‰ä¸€ä¸ªç”¨äºæ‰§è¡Œé‡å­å‚…é‡Œå¶å˜æ¢çš„å‡½æ•°
// [n:!N]å®šä¹‰ç±»å‹å‚æ•°ï¼Œ!N=å†…ç½®ç±»å‹å‚æ•°é™åˆ¶=éè´Ÿæ•´æ•°ç±»å‹, [n:!N]=næ˜¯ä¸€ä¸ªéè´Ÿæ•´æ•°ç±»å‹
// (qs:B^n) å®šä¹‰å‡½æ•°å‚æ•°ï¼Œ
def QFT[n:!N] (qs:B^n) mfree:B^n {
    // å¯¹æ¯ä¸ªæ¯”ç‰¹ä¸²åº”ç”¨Hadamardé—¨
    for i in [0..n) {        qs[i] := H(qs[i]);

        // å¯¹æ¯”ç‰¹ä¸²è¿›è¡Œç›¸ä½æ—‹è½¬æ“ä½œ
        for j in [i+1..n) {            qs[j] := U1(Ï€/2^(j - i), qs[j]);
        }
    }

    // æ‰§è¡Œæ¯”ç‰¹ä¸²çš„ä½ç¿»è½¬æ“ä½œ
    return swap_all(qs);
}

// å®šä¹‰ä¸€ä¸ªç”¨äºæ‰§è¡Œæ¯”ç‰¹ä¸²çš„ä½ç¿»è½¬æ“ä½œçš„å‡½æ•°
def swap_all[n:!N] (qs:B^n) mfree:B^n {
    // å¯¹æ¯”ç‰¹ä¸²è¿›è¡Œä½ç¿»è½¬æ“ä½œ
    for i in [0..n div 2) {      (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
    }

    return qs;
}

// å®šä¹‰ä¸€ä¸ªæ‰§è¡Œç›¸ä½æ—‹è½¬æ“ä½œçš„å‡½æ•°
def U1 (r:!â„, q:B) mfree {
    // å¦‚æœæ¯”ç‰¹ä¸²çš„å€¼ä¸º1ï¼Œå°±å¯¹å…¶è¿›è¡Œç›¸ä½æ—‹è½¬
    if q { phase(r) }
    return q;
}
def QFT[n:!N](x: int[n])mfree: int[n]{
	for k in [0..n div 2){
		(x[k],x[n-k-1]) := (x[n-k-1],x[k]);
	} //SWAP
	for k in [0..n){
		x[k] := H(x[k]);
		for l in [k+1..n){
			if x[l] && x[k]{
				phase(2*Ï€ * 2^(k-l-1));
			}
		}
	} //Superposition using H Gate and applying controlled RZ Gate
	return x;
}
//Missing Method to Check If Correct


// Quantum Key Distribution 
// - Simulates the generation of a secure key through an insecure channel


// Helper functions

// Returns 0 or 1 with equal probability
def rand(){
    return measure(H(false));
}

// Random number generator
def uniformInt(range:!â„•){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !â„•;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def prepareState(n:!â„•) { 
    // prepares n random bits each encoded as a qubit in a random base 
    bitsA := 0:!int[n];
    basesA := 0:!int[n];
    
    for i in [0..n){ // generates random bits and random bases
	bitsA[i] = rand();
        basesA[i] = rand();
    }

    qubitsA := bitsA:int[n];
    for i in [0..n){ // encodes each qubit to be sent in the corresponding base
        if basesA[i] {qubitsA[i] = H(qubitsA[i]);}
    }

    return(bitsA, basesA, qubitsA);
}

def measureB[n:!â„•](qubitsA:int[n]) { 
    // generates n random bases to measure the received bits
    basesB := 0:!int[n];
    
    for i in [0..n){ // generates random bases
        basesB[i] = rand();
    }

    for i in [0..n){ // decodes each received qubit according to the bases
        if basesB[i] {qubitsA[i] := H(qubitsA[i]);}
    }
    bitsB := measure(qubitsA);
    return (bitsB, basesB);
}

def compareBases[n:!â„•](basesA:!int[n], basesB:!int[n]) { 
    // returns the correctly guessed bases
    indices := 0:!int[n];
    nInfo := 0:!â„•;
    indices = ~(basesA âŠ• basesB); // keeps indices where bases coincide
    for i in [0..n){ 
        nInfo+=indices[i];
    }
    return (indices, nInfo);
}

def computePresumablySharedInfo[n:!â„•](indices:!int[n], bitsA:!int[n], 
                                bitsB:!int[n], nInfo:!â„•) {

    infoA := 0:!int[nInfo]; // contains the presumbaly shared information on A part
    infoB := 0:!int[nInfo];
    count := 0:!â„•;
    i := 0:!â„•;
    while (count < nInfo) { // computes the presumably shared information
        if indices[i] {
            infoA[count] = bitsA[i];
            infoB[count] = bitsB[i];            
            count+=1;
        }
        i+=1;
    }
    return (infoA, infoB);
}

def checkEavesdropper[n:!â„•](infoA:!int[n], 
                            infoB:!int[n],
                            nSharedBits:!â„•) {
    bitsRevealed := 0:!â„•;
    noE := true;
    count := 0:!â„•;
    i := 0:!â„•;
    notAlreadyChecked := 2^n - 1 coerce !int[n];
    while (bitsRevealed < n - nSharedBits) { 
    // checks that no eavesdropper has gained info about the shared secret  
    // by comparing some bits
        i = uniformInt(n);
        if notAlreadyChecked[i] {
            // checks that random bits coincide
            noE &= (infoA[i] == infoB[i]);
            notAlreadyChecked[i] = false;
            bitsRevealed+=1;
        }
    }
    return (notAlreadyChecked, noE);
}

def computeSharedInfo[n:!â„•](indices:!int[n], bitsA:!int[n], 
                            bitsB:!int[n], nInfo:!â„•, nSharedBits:!â„•) { 
    // computes shared information
    
    // nSharedBits is the number of remaining bits after 'burning' some of them 
    // to detect the presence of an eavesdropper
    assert (nSharedBits < nInfo);

    (infoA, infoB) := computePresumablySharedInfo(indices, bitsA, bitsB, nInfo);

    (notAlreadyChecked, noE) := checkEavesdropper(infoA, infoB, nSharedBits);

    sharedInfo := 0:!uint[nSharedBits]; 
    // contains the shared information to be used if no eavesdroper has been detected
    
    count := 0:!â„•;
    i := 0:!â„•;
    while (count < nSharedBits) { // computes the shared information
        if notAlreadyChecked[i] {
            sharedInfo[count] = infoA[i];
            count+=1;
        }
        i+=1;
    }

    return (sharedInfo, noE); 
    // returns the shared information and the detection or not of an eavesdropper
}

def qkd[n:!â„•](channel: int[n] !â†’ int[n]){
    (bitsA, basesA, qubitsA) := prepareState(n); 
    // prepares the random bases and bits and the qubits to be send to B

    qubitsA := channel(qubitsA); 
    // simulates the transfer through a potentially malicious channel 

    (bitsB, basesB) := measureB(qubitsA); 
    // generates the guesses from B

    (indices, nInfo) := compareBases(basesA, basesB); 
    // compares the bases between A and B


    nSharedBits := floor((2/3)*nInfo) coerce !â„•;
    
    (sharedInfo, noE) := computeSharedInfo(indices, bitsA, bitsB, nInfo, nSharedBits);  
    // computes the shared information obtained 
    // and the potential detection of an eavesdropper
    
    return (noE, nSharedBits); 
    // returns whether an eavesdropper was detected (0 if detection)
    // and how many bits of info are shared
}

/* TEST */

def testQKDnoE() { // tests QKD with no eavesdropper 
    n := 12;
    channel := Î»(b:int[n]). b; // channel = id
    (noE, nSharedBits) := qkd[n](channel);
    assert(noE); // no detection of eavesdropper (noE=1)
    print(noE, nSharedBits);
}

def testQKDE() { // tests QKD with an eavesdropper 
    n := 12;
    channel := Î»(b:int[n]){ for i in [0..n) {b[i] := H(b[i])}; return b; }; 
    // channel alters the qubits
    (noE, nSharedBits) := qkd[n](channel);
    print(noE, nSharedBits);
}

/* EXAMPLE CALL */

def main() {
    // tests QKD both with and without an eavesdropper
    
    // test without eavesdropper should always be of the form (1,n)
    testQKDnoE();

    // test with an eavesdropper may be of the form (0,n) if its presence is detected
    testQKDE(); 
}
def main(){
    return CX(1:ğ”¹,0:ğ”¹);
}

def CX(const x:ğ”¹,y:ğ”¹):ğ”¹{
    if x{
        y:= X(y);
    }

    return y;
}def main(){
    return Teleportation();
}

def Teleportation(){
    // Initialize Qubits - 'a' qubit is to be teleported by Alice
    // to Bob
    a:=0:ğ”¹;
    b:=0:ğ”¹;
    c:=0:ğ”¹;
    // Alice's Operations
    // Creating the Bell State
    b:=H(b);
    if b{
        c:=X(c);
    }

    //Alice applies CX and H to 'a' qubit
    if a{
        b:= X(b);
    }
    a:=H(a);
    // Alice measures her qubits 'a' and 'b'
    ma1:=measure(a);
    ma2:=measure(b);
    print(ma1);
    print(ma2);
    //Bob's measurement
    //c:=Z(c);
    //c:X(c);
    return (c);
}// Random number generators

def uniformInt(range:!â„•){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !â„•;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}

// Shor code (Quantum error correction)
// - Returns the qubit Ïˆ where Ïˆ is encoded to a 9-qubit state and then  
// - passed through a noisy channel potentially altering the state of one of the qubits


// Helper function

def applyToEach[Ï„,Ï„'](triple:Ï„^3, f: Ï„ !â†’ Ï„') { // apply a function to each element of a triple
    (h0,h1,h2) := triple;
    fTriple := (f(h0),f(h1),f(h2));

    return fTriple;
}


def triplicate(Ïˆ:ğ”¹) mfree {  // entangle a qubit with two duplicates 
    Ïˆ := (dup(Ïˆ), dup(Ïˆ), Ïˆ);

    return Ïˆ;
}

def encode(Ïˆ:B) {  // encode a single qubit Ïˆ into a 9-qubit state
    Ïˆ := triplicate(Ïˆ);
    Ïˆ := applyToEach(Ïˆ, H);
    Ïˆ := applyToEach(Ïˆ, triplicate);

    return Ïˆ;
}

def correct(Ïˆ:ğ”¹^3) { // correct a single bit-flip error if there is one
    // measure the error syndrome
    a1 := measure(Ïˆ[0] âŠ• Ïˆ[1]);
    a2 := measure(Ïˆ[0] âŠ• Ïˆ[2]);

    // apply the appropriate correction
    if (a1 && a2) {
        Ïˆ[0] := X(Ïˆ[0]);
    } else if (a1) {
        Ïˆ[1] := X(Ïˆ[1]);
    } else if (a2) {
        Ïˆ[2] := X(Ïˆ[2]);
    }

    return Ïˆ;
}

def correctBitFlip(Ïˆ:(B^3)^3) {  // correct a single bit-flip error in each triplet of a triplet of triplets
    Ïˆ := applyToEach(Ïˆ, correct);

    return Ïˆ;
}

def correctPhaseFlip(Ïˆ:(B^3)^3) { // correct a single phase-flip error
    Ïˆ := applyToEach(Ïˆ, reverse(triplicate));
    Ïˆ := applyToEach(Ïˆ, H);
    Ïˆ := correct(Ïˆ);

    return Ïˆ
}

def shor_code(Ïˆ:B,  channel: (B^3)^3 !â†’ (B^3)^3){ // simulate the Shor code error-correcting process
    Ïˆ := encode(Ïˆ);

    Ïˆ := channel(Ïˆ);

    Ïˆ := correctBitFlip(Ïˆ); 
    Ïˆ := correctPhaseFlip(Ïˆ);

    Ïˆ := reverse(triplicate)(Ïˆ);

    return Ïˆ;
}

/* EXAMPLES */

def channel(Ïˆ:(ğ”¹^3)^3) { // flip both one qubit and its phase in a 3x3 structure
    Ïˆ[0][1] := Z(Ïˆ[0][1]); 
    Ïˆ[0][1] := X(Ïˆ[0][1]); 
    return Ïˆ; 
}

def main() {
    // Example 1: basis state
    Ïˆ := 1:ğ”¹; 
    Ï† := shor_code(Ïˆ, channel); 
    // verifies that Ï† = 1
    forget(Ï†=1);

    // Example 2: superposition
    Ïˆ := H(1:ğ”¹); 
    Ï† := shor_code(Ïˆ, channel); 
    // verifies that Ï† = H(|1>)
    return Ï†;
}// Simon's algorithm 

def main() {
  return Simon();
}

def Simon(){
  // Initializing Qubits for Inputs - a,b,c and Oracle - d,e,f
  a:=0:ğ”¹;
  b:=0:ğ”¹;
  c:=0:ğ”¹;
  d:=0:ğ”¹;
  e:=0:ğ”¹;
  f:=0:ğ”¹;

  // Applying Hadamard to Inputs
  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Encoding 011 secret key in the Oracle

  if b{
    d := X(d);
  }

  if b{
    e := X(e);
  }

  if c{
    d := X(d);
  }

  if b{
    f := X(f);
  }

  if c{
    e := X(e);
  }

  if c{
    f := X(f);
  }

  // Applying Hadamard to Inputs

  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Measure the d,e,f qubits for variable consumption

  md:=measure(d);
  me:=measure(e);
  mf:=measure(f);

  return (a,b,c,md,me,mf);
}// Simon's algorithm 

def main() {
  return Simon();
}

def Simon(){
  // Initializing Qubits for Inputs - a,b,c and Oracle - d,e,f
  a:=0:ğ”¹;
  b:=0:ğ”¹;
  c:=0:ğ”¹;
  d:=0:ğ”¹;
  e:=0:ğ”¹;
  f:=0:ğ”¹;

  // Applying Hadamard to Inputs
  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Encoding 011 secret key in the Oracle

  if b{
    d := X(d);
  }

  if b{
    e := X(e);
  }

  if c{
    d := X(d);
  }

  if b{
    f := X(f);
  }

  if c{
    e := X(e);
  }

  if c{
    f := X(f);
  }

  // Applying Hadamard to Inputs

  a:=H(a);
  b:=H(b);
  c:=H(c);

  // Measure the d,e,f qubits for variable consumption

  md:=measure(d);
  me:=measure(e);
  mf:=measure(f);

  return (a,b,c,md,me,mf);
}def main() {
  return Hadamard();
}

def Hadamard() {
  x:=0:ğ”¹;
  return H(x);
}

def PauliZ() {
  z:=1:ğ”¹;
  return Z(z);
}

def PauliY() {
  y:=1:ğ”¹;
  return Y(y);
}

def PauliX() {
  x:=0:ğ”¹;
  return X(x);
}def main(){
    return SuperDenseCoding();
}

def SuperDenseCoding(){
    a:=0:ğ”¹;
    b:=0:ğ”¹;

    // Bell State Preparation
    a:=H(a);
    if a{
        b:= X(b);
    }
    // Alice's Operation - 11 is sent 
    a:=Z(a);
    a:=X(a);
    // Bob's Operation 
    if a{
        b:= X(b);
    }
    a:=H(a);
    return (a,b);
}def main() {
  return SuperDenseCoding();
}

def SuperDenseCoding(){
  a:=0:ğ”¹;
  b:=0:ğ”¹;
  
  // Bell State Preparation
  a:=H(a);
  if a{
    b := X(b);
  }

  // Alice's Operation - 11 is sent
  a:=Z(a);
  a:=X(a);

  // Bob's Operation
  if a{
    b := X(b);
  }

  a:=H(a);

  return(a,b);
}def main() {
    return UniformSuperposition[1]();
}

def UniformSuperposition[n:!â„•]():ğ”¹^n{
    qubits := vector(n,0:ğ”¹); //vector of length n filled with zeros


    for i in [0..n){
        qubits[i]:= H(qubits[i]);
    }
    return qubits;


}


// Superposition generation
// - Generates the (normalized) superposition |0âŸ© + ... + |N-1âŸ© on k qubits  
//  
// - Requires N < 2^k

def superposition[k:!â„•](N:!â„•, qs:ğ”¹^k)mfree:ğ”¹^k{ 
    // generates the (normalized) superposition |0âŸ© + ... + |N-1âŸ© on k qubits

    assert(N <= 2^k); 
    // ensures that the biggest state |N-1âŸ© requires less than k qubits to be written
   
    n := floor(log(N)/log(2)) coerce !â„•;
    r := N - 2^n coerce !â„•;
    // decomposition N = 2^n + r

    // rotate first qubit
    (head,)~tail := qs; 
    Î¸ := 2*asin(sqrt(r)/sqrt(N));
    // sin(Î¸/2) = sqrt(r/N), cos(Î¸/2) = sqrt((N-r)/N) = sqrt(2^n/N)
	
    head := rotY(Î¸, head); 
    // |0âŸ© â†¦ cos(Î¸/2)|0âŸ© + sin(Î¸/2)|1âŸ© = sqrt(2^n/N) |0âŸ© + sqrt(r/N)|1âŸ©

    // state : 
    // (sqrt(2^n)/sqrt(N))|0âŸ©âŠ—(|0âŸ©âŠ— â‹¯ âŠ—|0âŸ©) + (sqrt(r)/sqrt(N))|1âŸ©âŠ—(|0âŸ©âŠ— â‹¯ âŠ—|0âŸ©)

    // conditionally on first qubit either prepare 
    // the uniform distribution on n qubits or 
    // (recursively) the remainder |0âŸ© + ... + |r-1âŸ©
    if head {
        tail := superposition(r, tail); // (|0âŸ© + ... + |r-1âŸ©)/sqrt(r)
    }
    else {
        for i in [0..n) { tail[i] := H(tail[i]); } // âˆ‘áµ¥|vâŸ©/sqrt(2^n)
    }

    // tail = (xâ‚, ..., xâ‚™, xâ‚™â‚Šâ‚, ..., xâ‚–) and 
    // head (= xâ‚€) is the MSB of (xâ‚, ..., xâ‚™, xâ‚€)
    for i in [0..n div 2) { (tail[i], tail[n-1-i]) := (tail[n-1-i], tail[i]); } 
    // tail = (xâ‚™, ..., xâ‚, xâ‚™â‚Šâ‚, ..., xâ‚–)
    
    qs:=(head,)~tail;                                                           
    // qs = (xâ‚€, xâ‚™, ..., xâ‚, xâ‚™â‚Šâ‚, ..., xâ‚–)
    
    for i in [0..(n+1) div 2) { (qs[i], qs[n-i]) := (qs[n-i], qs[i]); }         
    // qs = (xâ‚, ..., xâ‚™, xâ‚€, xâ‚™â‚Šâ‚, ..., xâ‚–)

    // state :   
    // (sqrt(2^n)/sqrt(N))|0âŸ©âŠ—(âˆ‘áµ¥|vâŸ©/sqrt(2^n)) + 
    // (sqrt(r)/sqrt(N))|1âŸ©âŠ—((|0âŸ© + ... + |r-1âŸ©)/sqrt(r)
    // = (1/sqrt(N))(|0âŸ© + ... + |N-1âŸ©)

    return qs;
}

/* TEST */

def test_superposition() { 
    k := 5;
    qs := vector(k, 0:ğ”¹);
    qs := superposition(19, qs);
    measure(qs);
}

/* EXAMPLE CALL */

def main() {
    N := 19;
    // generates the normalized superposition |0âŸ© + ... + |18âŸ© on 5 qubits
    qs := superposition(N,  vector(5, 0:ğ”¹)) as uint[5];

    // measures 0 <= n < 19 
    n := measure(qs); 
    assert(n < N);
    return(n);
}def solve[n:!â„•](bits:!ğ”¹^n){
  // prepare superposition between 0 and 1
  x:=H(0:ğ”¹);
  // prepare superposition between bits and 0
  qs := if x then bits else (0:int[n]) as ğ”¹^n;
  // uncompute x
  forget(x=qs[0]); // valid because `bits[0]==1`
  return qs;
}

// EXAMPLE CALL

def main(){
  // example usage for bits=1, n=2
  x := 1:!int[2];
  y := x as !ğ”¹^2;
  return solve(y);
}// def solve[n:!â„•](bits:!ğ”¹^n){
//   x:=H(0:ğ”¹);
//   qs := if x then bits else (0:int[n]) as ğ”¹^n;
//   forget(x=qs[0]); 
//   return qs;
// }


// def main(){
//   x := 1:!int[2];
//   y := x as !ğ”¹^2;
//   return solve(y);
// }




// å®šä¹‰ solve å‡½æ•°ï¼Œè¾“å…¥å‚æ•°æ˜¯ä¸€ä¸ªåä¸º bits çš„å¸ƒå°”æ•°ç»„ï¼Œé•¿åº¦ä¸º n
def solve[n:!â„•](bits:!ğ”¹^n) {
  // ä½¿ç”¨ H è¡¨ç¤ºå“ˆè¾¾ç›å¾·é—¨æ“ä½œç”Ÿæˆä¸€ä¸ªåˆå§‹é‡å­æ€ x
  x := H(0:ğ”¹);
  // æ ¹æ®åˆå§‹é‡å­æ€å’Œè¾“å…¥å‚æ•° bitsï¼Œæ„é€ ä¸€ä¸ªæ–°çš„é‡å­æ€ qs
  // å¦‚æœåˆå§‹é‡å­æ€ä¸º 1ï¼Œåˆ™ qs ç­‰äº bitsï¼›å¦åˆ™ï¼Œqs æ˜¯ä¸€ä¸ªå…¨0çš„ ğ”¹^n å¸ƒå°”æ•°ç»„
  qs := if x then bits else (0:int[n]) as ğ”¹^n;
  // å¿˜è®°é‡å­æ€ x å’Œ qs[0] ä¹‹é—´çš„ç­‰å¼
  forget(x=qs[0]);
  // è¿”å›æ„é€ å¥½çš„é‡å­æ€ qs
  return qs;
}

// å®šä¹‰ main å‡½æ•°
def main() {
  // å®šä¹‰ä¸€ä¸ªé•¿åº¦ä¸º 2 çš„æ•´å‹æ•°ç»„ xï¼Œå¹¶èµ‹å€¼ä¸º [1, 0]
  x := 1:!int[2];
  // å°† x å¼ºåˆ¶è½¬æ¢ä¸º ğ”¹^2 ç±»å‹çš„å¸ƒå°”æ•°ç»„ y
  y := x as !ğ”¹^2;
  // è°ƒç”¨ solve å‡½æ•°ï¼Œå°† y ä½œä¸ºå‚æ•°ä¼ å…¥ï¼Œå¹¶è¿”å›å…¶è¿”å›å€¼
  return solve(y);
}
def main() {
  return Teleportation();
}

def Teleportation(){

  // Initialize Qubits - 'a' qubit is to be teleported by Alice to Bob
  a:=0:ğ”¹;
  b:=0:ğ”¹;
  c:=0:ğ”¹;

  // Alice's Operations

  // Creating the Bell State
  b:=H(b);

  if b{
    c := X(c);
  }

  // Alice applies CX and H to 'a' qubit

  if a{
    b := X(b);
  }

  a:=H(a);

  // Alice measures her qubits 'a' and 'b'

  ma1:=measure(a);
  ma2:=measure(b);
  print(ma1);
  print(ma2);

  // Bob's measurement

  //c:=X(c);
  //c:=Z(c);

  return (c);
}def QFT[n:!N] (qs:B^n) mfree:B^n {
    for i in [0..n) {
        qs[i] := H(qs[i]);

        for j in [i+1..n) {
            qs[j] := U1(Ï€/2^(j - i), qs[j]);
        }
    }

    return swap_all(qs);
}

def swap_all[n:!N] (qs:B^n) mfree:B^n {
    for i in [0..n div 2) {
      (qs[i], qs[n-i-1]) := (qs[n-i-1], qs[i]);
    }

    return qs;
}

def U1 (r:!â„, q:B) mfree {
    if q { phase(r) }
    return q;
}


def solve[n:!â„•](bits:!ğ”¹^n){
  // prepare superposition between 0 and 1
  x:=H(0:ğ”¹);
  // prepare superposition between bits and 0
  qs := if x then bits else (0:int[n]) as ğ”¹^n;
  // uncompute x
  forget(x=qs[0]); // valid because `bits[0]==1`
  return qs;
}

// EXAMPLE CALL

// def main(){
//   // example usage for bits=1, n=2
//   x := 1:!int[2];
//   y := x as !ğ”¹^2;
//   return solve(y);
// }

def main(){
    // å®šä¹‰ x ä¸ºä¸€ä¸ªäºŒè¿›åˆ¶ä½é•¿åº¦ä¸º2çš„æ•´æ•°ï¼Œåˆå§‹å€¼ä¸º1
    x := 1:!int[2];
    // ä½¿ç”¨ as è¿ç®—ç¬¦å°† x è½¬æ¢ä¸ºä¸€ä¸ªé•¿åº¦ä¸º2çš„å¸ƒå°”å€¼æ•°ç»„ï¼Œèµ‹å€¼ç»™å˜é‡ y
    y := x as !ğ”¹^2;
    // è°ƒç”¨ solve() å‡½æ•°ï¼Œå¹¶å°† y ä½œä¸ºå‚æ•°ä¼ é€’ç»™è¯¥å‡½æ•°ï¼Œå¹¶è¿”å›å…¶ç»“æœ
    return solve(y);
}
// def main() {
//     // å®šä¹‰æ•´æ•°å˜é‡ x å’Œ yï¼Œå¹¶èµ‹åˆå€¼ä¸º 3 å’Œ 5
//     x := 3;
//     y := 5;

//     // è®¡ç®— x å’Œ y çš„å’Œï¼Œå¹¶å°†ç»“æœèµ‹å€¼ç»™å˜é‡ z
//     z := x + y;

//     // è¾“å‡ºå˜é‡ z çš„å€¼
//     print(z);
// }


def main() {
    x := 0 ;
    x : B ;
    print(measure(x));
}
// å®šä¹‰ cost å’Œ mixer å‡½æ•°
def cost(qubits : Qubit[], iter : Int) : Double {
    // å®šä¹‰æ— å‘å›¾çš„é‚»æ¥çŸ©é˜µï¼Œè¡¨ç¤º 4 æ¡è¾¹ 6 ä¸ªç‚¹çš„æ— å‘å›¾
    adj_matrix := [
        [false, true, false, false, true, true],
        [true, false, true, false, false, true],
        [false, true, false, true, false, true],
        [false, false, true, false, true, true],
        [true, false, false, true, false, true],
        [true, true, true, true, true, false]
    ];
    // è®¡ç®—æœ€å¤§åˆ‡å‰²çš„æˆæœ¬
    cut := 0.0;
    for i in 0 .. Length(qubits) - 1 {
        for j in i + 1 .. Length(qubits) - 1 {
            if adj_matrix[i][j] {
                weight := 1.0 - Measure([qubits[i], qubits[j]]);
                cut += weight;
            }
        }
    }
    return cut;
}

// function mixer(qubits : Qubit[], gamma : Double) : Unit {
//     // åº”ç”¨ Hadamard é—¨
//     ApplyToEach(H, qubits);
//     // åº”ç”¨ Ising æ¨¡å‹æ··åˆé¡¹
//     for i in 0 .. Length(qubits) - 2 {
//         let theta = gamma * (Double(i) + 1.0) / Double(Length(qubits) - 1);
//         for j in i + 1 .. Length(qubits) - 1 {
//             let w = if j == i + 1 then 1.0 else 2.0;
//             CPhase(theta * w, (qubits[i], qubits[j]));
//         }
//     }
//     // åº”ç”¨ Hadamard é—¨
//     ApplyToEach(H, qubits);
// }

// // å®šä¹‰ QAOA ç®—æ³•å‡½æ•°
// operation qaoa(p : Int, cost_func : ((Qubit[], Int) => Double), mixer_func : ((Qubit[], Double) => Unit)) : Double {
//     // åˆ›å»ºé‡å­æ¯”ç‰¹æ•°ç»„å’Œåˆå§‹è¶…ä½ç½®æ€
//     using (qubits = Qubit[p]) {
//         ApplyToEach(H, qubits);
//         // åº”ç”¨ QAOA è¿­ä»£
//         for i in 1 .. p {
//             let gamma = 2.0 * Pi() * Double(i) / Double(p);
//             cost_func(qubits, i);
//             mixer_func(qubits, gamma);
//         }
//         // æµ‹é‡ç»“æœ
//         let result = MeasureAllZ(qubits);
//         ResetAll(qubits);
//         return result;
//     }
// }

// // æµ‹è¯• QAOA ç®—æ³•
// function main() : Unit {
//     let p = 2;
//     let result = qaoa(p, cost, mixer);
//     Message($"QAOA result: {result}");
// }
// åˆ›å»ºä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œè¡¨ç¤ºæ— å‘å›¾ä¸­çš„è¾¹
edges := [
    [0, 1],
    [0, 2],
    [0, 3],
    [1, 2],
    [1, 3],
    [2, 3]
];

// è¾“å‡ºæ•°ç»„ä¸­çš„å…ƒç´ 
for (i in 0 .. Length(edges) - 1) {
    Message($"{edges[i]} ");
}




// // è¾“å‡ºæ— å‘å›¾çš„è¡¨ç¤º
// for (i in 0 .. 3) {
//     for (j in i + 1 .. 3) {
//         if ([i, j] in edges or [j, i] in edges) {
//             Message($"({i}, {j})");
//         } else {
//             Message($"({i}, {j}) -- 0");
//         }
//     }
// }
def main() {
  return UniformSuperposition[1]();
}

def UniformSuperposition[n:!â„•]():ğ”¹^n{
  qubits := vector(n,0:ğ”¹); // vector of length n filled with zeros
  for i in [0..n){
    qubits[i] := H(qubits[i]);
  }
  return qubits;
}